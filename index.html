<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Functional Programming: What Why and How</title>

	<meta name="description" content="An introductory talk for funcational programming in JavaScript">
	<meta name="author" content="That JS Dude">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="shortcut icon" href="images/favicon.jpg">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/serif.css" id="theme">
	<link rel="stylesheet" type="text/css" href="css/extra-style.css">
	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<section>
					<h2>Functional Programming</h2>
					<h4>What, Why and How</h4>
					<br>
					<br>
					<p class="fragment"><a href="https://goo.gl/pdio1i">Just twitted the slides <strong style="color:purple">@jsdude005</strong></a></p>
					<br>
					<br>
					<p>
						<a href="http://thatjsdude.com">ThatJSDude.com</a> / <a href="http://twitter.com/jsdude005">@jsdude005</a>
					</p>
					<p>
						<small><a href="http://www.youtube.com/c/ThatJSDude">youtube.com/c/ThatJSDude </a></small>
					</p>
				</section>
				<section>
					<img src="images/evolution.png">
				</section>
				<section>
					<h2>Agenda</h2>
					<ul>
						<li class="fragment">Three Basics of Functional Programming</li>
						<li class="fragment">Five Popular patterns and techniques</li>
						<li class="fragment">Three higher level Geeky things</li>
						<li class="fragment">Transform OOP to FP</li>
						<li class="fragment">...and lots of fun</li>
					</ul>
				</section>
				<!-- <section>
					<h2>TODO</h2>
					<ol>
                                               <li><a href="http://pragmatists.pl/blog/2017/05/higher-order-functions-in-lodash/">higher order function</a>
						<li>remove var</li>
						<li>Make map, filter, reduce, part slimmer</li>
						<li>Functor, Monads, Applicatives</li>
						<li>Take a OOP example and convert it to FP</li>
						<li>why</li>
						<li>Free tip</li>
					</ol>
				</section> -->
			</section>
			<!-- <section>
				<section>
					<h2>Bragging time!</h2>
					<p>I know you don't care</p>
				</section>
				<section>
					<img src="images/youtube.png" alt="">
					<aside class="notes">
						<p>My wife said: if i don't get 50,000 subscriber this year, she won't pay for the rent anymore</p>
						<p>if you don't subscribe my youtube channel, you wont get a lunch box</p>
					</aside>
				</section>
				<section>
					<p>Get the website name</p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Why</h1>
				</section>
				<section>
					<h2>FP Shines</h2>
					<ul>
						<li class="fragment">Cloud/Big Data for data processing, filtering, aggregating</li>
						<li class="fragment">Easier to figure out what the hell is going on in a larger code base</li>
						<li class="fragment">Concepts are used in web application</li>
						<li class="fragment">Easier to read, maintain, test</li>
						<li class="fragment">Avoid a mess of states or multi threading issues</li>
						<li class="fragment">Modular the functionality</li>
					</ul>
					<br>
					<br>
					<p><small>Ref: <a href="http://scalafp.com/book/benefits-of-functional-programming-in-scala.htm"></a> <a href="https://hackernoon.com/why-functional-programming-matters-c647f56a7691">Why FP matters</a></small></p>
					<aside class="notes">
						<li>Parallel/concurrent programming is easier</li>
						<p>You don't have to worry about deadLock, race condition</p>
						<p>No piece of data is modified twice ...even not in two different threads</p>
						<p>, where ObjectOrientedProgramming is modular in the dimension of different components.</p>
						<li class="">Will discuss more as we are going through</li>
					</aside>
				</section>

				<!-- <section>
					<h2>Programming Language</h2>
						<ul>
							<li class="fragment">Imperative Language</li>
							<li class="fragment">Object Oriented Language</li>
							<li class="fragment">Functional Language</li>
							<li class="fragment">Multi paradaigmm language</li>
						</ul>
						<br>
						<br>
					<p><small>Ref: <a href="https://medium.com/functional-javascript/introduction-to-functional-javascript-45a9dca6c64a">programming Paradaigm</a></small></p>
					<aside class="notes">
						<p>we have OOP...working good why we need FP?</p>
						<p>An imperative programming language is one in which program state change is achieved by executing a series of statements, and does flow control primarily using conditional statements, loop statements and function calls. </p>
					</aside>
				</section> -->
			<!-- 	<section>
					<ul>
						<li class="fragment">Code works more than it doesn’t.</li>
						<li class="fragment">Unit tests are easier to write.</li>
						<li class="fragment">Unit tests break faster allowing me to fix broken code they found faster.</li>
						<li class="fragment">Easier to figure out what the hell is going on in a larger code base. If something breaks, it’s easier to pull things
							apart and improve the testing of those parts to prevent it from happening again. Not like usual spaghetti that can
							occur with mutable state.</li>
						<li class="fragment">Don’t get bit (as much) by concurrency/parallelism bugs that can arise in server or testing environments.</li>
					</ul>
				</section> -->
			</section>
			<section>
				<section>
					<h1>What</h1>
					<aside class="notes">
						<h2>This was suppose to be a simple question</h2>
					</aside>
				</section>
				<section>
					<h2>Ask the geeky guy</h2>
					<ul>
						<li class="fragment">Monads, Monoids, Lift, Functors, actuators</li>
						<li class="fragment">Immutable, Higher Order, Tail call optimization</li>
						<li class="fragment">Lazy evaluation, composition, determinism</li>
					</ul>
					<img class="fragment" src="images/speak.jpg">
					<aside class="notes">
						<p>He started shower of these words</p>
						<p>I asked him where can I learn it... he said...my code speaks</p>
						<p>after 40 minutes of talk during lunch break... my head starts spinning</p>
					</aside>
				</section>
				<!-- <section>
					<h2>Ask my Manager</h2>
					<img class="fragment" src="images/manager.gif" alt="">
					<ul>
						<li class="fragment">I am the JIRA man</li>
					</ul>
					<p><small><a href="https://www.quora.com/Why-are-many-experienced-programmers-upset-at-functional-programming">Why experience developers upset on FP</a></small></p>
					<aside class="notes">
						<p>Manager Manager not very angry: and starting yelling...don't you know I neve code</p>
						<p>I am the JIRA professional with occasional power point slide presenter</p>
					</aside>
				</section>
				<section>
					<h2>Junior Developer</h2>
					<img class="fragment" style="height:450px;" src="images/junior.jpg" alt="">
					<aside class="notes">
						<li>It's a trap door. </li>
						<li>Once you start functional programming...no one else..understand your code</li>
						<li>But once you can put a lot of FP code... no one can fire you</li>
						<li><strong>It's a job security</strong></li>
					</aside>
				</section>
				<section>
					<h4>Every major idea starts with Google search</h4>
					<img class="fragment" style="height: 600px;" src="images/day.jpg">
					<aside class="notes">
						<h2>Greatest Mistake was to google</h2>
					</aside>
				</section> -->
				<section>
					<h2>What the func?</h2>
					<ul>
						<li class="fragment">Dizzying number of “functional” characteristics</li>
						<li class="fragment">Lambdas!!!</li>
						<li class="fragment"> Learn Haskell</li>
						<li class="fragment">Is this only a hype or a geeky thing?</li>
						<li class="fragment">Why it's called functional?</li>
						<li class="fragment">Is everything else is dysfunctional?</li>
						<li class="fragment">Why the hell, I  have to ruin my weekend on this?</li>
					</ul>
					<br>
					<br>
					<p><small>Ref: <a href="https://clojurefun.wordpress.com/2012/08/27/what-defines-a-functional-programming-language/">What is Functional Programming</a></small></p>
					<aside class="notes">
						<p>When people talk about functional programming</p>
						<h2>Then i realized I have nothing else to do in the weekend...anyway</h2>
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>Fully lost!</h1>
					<img src="images/lost.jpg" alt="">
					<p><small>Like everyone else</small></p>
				</section>
				<section>
					<h2>Learn driving</h2>
					<p><img class="fragment" src="images/driving1.png" alt=""></p>
					<!-- <img style="height:300px" src="images/driving.jpg" alt="" class="fragment"> -->
					<br>
					<br>
					<br>
					<p><small>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">Charles Scalfani: So you want to be a functional programmer</a></small></p>
					<aside class="notes">
						<p>Charles Scalfani</p>
					</aside>
				</section>
				<section>
					<img src="images/driving2.jpg" alt="">
				</section>
				<section>
					<h2>Forget everything</h2>
					<img src="images/forget.png" alt="">
					<p> you know</p>
				</section>
				<section>
					<img style="height:500px;" src="images/driving3.png" alt="">
					<aside class="notes">
						<h4>Now you will be driving space craft</h4>
						<p>No back gear</p>
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>Let's Start</h1>
					<img src="images/start2.jpg" alt="">
				</section>
				<section>
					<h2>Functional Programming</h2>
					<ul>
						<li class="fragment">Application evolves around function </li>
						<li class="fragment">With only one ground rule: <strong class="danger">No side effect</strong></li>
						<li class="fragment">Don’t <strong>rely on data outside</strong> of the current function</li>
						<li class="fragment">Don’t <strong>change data outside</strong> of the current function</li>
						<li class="fragment">Every other “functional programing” things are derived from this property</li>
						<li class="fragment">Use this as a guide rope</li>
					</ul>
					<br>
					<br>
					<p><small>Ref: <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">Practical Functional Programming</a></small></p>
					<aside class="notes">

					</aside>
				</section>
				<section>
					<h2>This is a function</h2>
					<pre class="hljs javascript"><code>
function add(x, y){
  return x + y;
}
					</code> </pre>
					<pre class="hljs fragment javascript" data-trim><code>
add(1, 2); // output is 3
add(1, 2); // output still is 3
add(1, 2); // WILL ALWAYS output 3
					</code></pre>
					<ul>
						<!-- <li class="fragment">Always produce the same output for same inputs</li>
						<li class="fragment">Only operate on their input parameters</li> -->
						<li class="fragment">No side effect</li>
					</ul>
				</section>
				<section>
					<h2>What about this one?</h2>
					<pre class=" hljs"><code data-trim>
function mouseOnLeftSide(mouseX) {
    return mouseX < window.innerWidth / 2;
}
					</code></pre>
					<!-- <pre class="fragment hljs java" data-trim><code>
public int addNumbers(int x, int y) {
    int result = x + y;
    Database.write(result);
    return result;
}
					</code></pre> -->
					
					<aside class="notes">
						<p>Not pure. </p>
						<p>Chnage the browser width and for same position of mouse the result varies</p>
						<p><strong>Impure is not testable</strong></p>
						<ul>
							<li class="">Bug: a user reported the function doesn't work for window is less than 500 px</li>
							<li class="">How do you test this?
								<ul class="">
									<li>manually test by loading up your browser</li>
									<li>write some unit tests</li>
								</ul>
							</li>
							<li class="">You can not write unit test</li>
							<li class="">function relies on window.innerWidth</li>
						</ul>
					</aside>
					<p class="fragment"><small>Few more... impure function</small></p>
					<pre class="hljs fragment"><code data-trim>
writeFile(fileName);
updateDatabaseTable(sqlCmd);
sendAjaxRequest(ajaxRequest);
openSocket(ipAddress);
					</code></pre>
					<ul>
						<li class="fragment">Rely on things outside of input parameter</li>
						<li class="fragment">Can't always predict their behavior/output</li>
						<li class="fragment">They will have <strong>side effect</strong></li>
						<li class="fragment">Non FP (C#, Java, JS) has tons of these</li>
					</ul>
					<aside class="notes">
						<p>In Imperative Programming Languages such as JavaScript, Java, and C#, Side Effects are everywhere. This makes debugging
							very difficult because a variable can be changed anywhere in your program. So when you have a bug because a variable
							is changed to the wrong value at the wrong time, where do you look? Everywhere? That’s not good.</p>
					</aside>
				</section>
				<section>
					<h2>Dark side of side effect</h2>
					<p>When a function produces a side effect you have to know more than just its inputs and output</p>
					<br>
					<ul>
						<li class="fragment">To understand what that function does</li>
						<li class="fragment">You have to know the context and the history</li>
						<li class="fragment">It makes function harder and unpredictable</li>
						<li class="fragment">Harder to test and harder to debug</li>
					</ul>
				</section>
				<!-- <section>
					<h2>Impure function</h2>
					<p>In Imperative Programming Languages such as JavaScript, Java, and C#, Side Effects are everywhere</p>
					<p class="fragment">This makes debugging very difficult because a variable can be changed anywhere in your program. </p>
					<p class="fragment">So when you have a bug because a variable is changed to the wrong value at the wrong time, where do you look? Everywhere?
						That’s not good.</p>
				</section> 
				<section>
					<h2>Two Types of functions</h2>
					<pre class="hljs javascript" ><code>
//pure function
function add(x, y) {
    return x + y;
}
					</code></pre>
					<pre class="hljs fragment java"><code>
//impure function
public int addNumbers(int x, int y) {
    int result = x + y;
    Database.write(result);
    return result;
}
					</code> </pre>
					<aside class="notes">
						<p>If the database <strong style="color:red">throws an error</strong> your function will blow up</p>
						<p>Though nothing wrong with your core intention or your input</p>
					</aside>
				</section> -->
				<section>
					<h2>Pure Function</h2>
					<ul>
						<li class="fragment">Output relies solely on input values</li>
						<li class="fragment">Always produce same output for same inputs.</li>
						<li class="fragment">Does not produce an observable side effect</li>
						<li class="fragment">Does not change the program's state</li>
						<li class="fragment">Highly testable and reusable</li>

					</ul>
					<aside class="notes">
						This slide has fragments which are also stepped through in the notes window.
					</aside>
				</section>
				<section>
					<h2>Convert Impure to pure</h2>
					<p class="fragment">Make global variable local</p>
					<pre class="fragment"><code class="hljs" data-trim>
const myFunc = function(y){
  const x = 10;
  return x + y;
}

console.log(myFunc(3)); //13
console.log(myFunc(3)); //13
					</code></pre>
					<p class="fragment">Pass as parameter</p>
					<pre class="fragment"><code class="hljs" data-trim>
const x = 10;
const myFunc = function(x, y){
  return x + y;
}

console.log(myFunc(x, 3)); //13
console.log(myFunc(x, 3)); //13
					</code></pre>
				</section>
				<section>
					<p>Basic Concept-1</p>
					<h2>Use Pure function</h2>
				</section>
				<!-- <section>
					<h2>Reality</h2>
					<ul>
						<li class="fragment">Program will always produce some side effects</li>
						<li class="fragment">Cannot eliminate Side Effects completely</li>
						<li class="fragment">You can only confine them. minimize them</li>
						<li class="fragment"> Segregate impure from the rest of the program.</li>
					</ul>
					<aside class="notes">
						<li class="">To interface with real world, some parts must be impure</li>
					</aside>
				</section> -->
			</section>
			<section>
				<section>
					<h1>First Class</h1>
					<img style="height:450px" src="images/firstClass1.jpg" alt="">
				</section>
				<section>
					<h2>function is first class citizen</h2>
					<ul>
						<li class="fragment">Use function as value</li>
						<li class="fragment">Set function to a variable</li>
						<li class="fragment">Pass function as parameter</li>
						<li class="fragment">return function as a value</li>
					</ul>
					<pre class="fragment"><code>
// function expression
const doubleIt = x => x * 2;
					</code></pre>
					<aside class="notes">
						<p class="danger">So many things are related: first class, higher order, closure... make it simple</p>
					</aside>
				</section>
				<!-- <section>
					<h2>Higher Order Function</h2>
					<ul>
						<li class="fragment">function is a first-class citizen of the language.</li>
						<li class="fragment">function is just another value.</li>
						<li class="fragment">Just another value.</li>
						<li class="fragment">You can pass functions as parameters</li>
						<li class="fragment">return functions</li>
						<li class="fragment">Also allows to abstract values and actions </li>
					</ul>
					<br>
					<br>
					<p><small>ref: <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">higher order function</a></small></p>
					<aside class="notes">
						<p>In Functional Programming, a function is a first-class citizen of the language</p>
						<p>Higher Order Functions are functions that accept a function, and/or return a function </p>
					</aside>
				</section> -->
				<section>
					<h2>Higher order function</h2>
					<ul>
						<li>Either take function as argument</li>
						<li>Or return function</li>
					</ul>
					<!-- <pre><code>
function makeAdder(constantValue) {
    return function adder(value) {
        return constantValue + value;
    };
}
					</code></pre>
					<pre class="fragment"><code>
var add10 = makeAdder(10);
console.log(add10(20)); // prints 30
console.log(add10(30)); // prints 40
console.log(add10(40)); // prints 50
					</code></pre>
					<aside class="notes">
						This behavior is very important because without it, functions that return functions wouldn’t be very useful. So it’s important
						we understand how they work and what this behavior is called. This behavior is called a Closure.
					</aside>
				</section>
				<section>
					<h2>Another Example</h2> -->

					<pre class="fragment hljs javascript"><code>
function greaterThan(n) {
  return function(m) {
    return m > n;
  };
}
					</code></pre>
					<pre class="fragment hljs javascript"><code data-trim>
const greaterThan10 = greaterThan(10);
greaterThan10(11); //true
greaterThan10(7); //false
					</code></pre>
					<pre class="fragment hljs javascript"><code data-trim>
const greaterThan15 = greaterThan(15);
greaterThan15(11); //false
greaterThan15(21); //true
					</code></pre>
				</section>
				<!-- <section>
					<h2>Closure</h2>
					<p><small>Impure and mutable version</small></p>
					<pre class="hljs javascript"><code data-trim>
function counter(){
	var count = 0;
	return function(){
		return count++;
	}
}
					</code></pre>
					<pre class="fragment hljs javascript"><code data-trim>
const myClock = counter();
myClock(); //0
myClock(); //1
myClock(); //2
myClock(); //3
				</code></pre>
				<p class="fragment">Accessing outer scope variable is called <strong>Closure</strong></p>
				<p><small>ref: <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">higher order function</a></small></p>
				</section> -->
				<section>
					<p>Basic Concept-2</p>
					<h2>Function is First Class</h2>
				</section>
			</section>
			<section>
				<section>
					<h1>Immutability</h1>
				</section>
				<!-- <section>
					<img src="images/immutable.png">
					<aside class="notes">
						<p>I am programming </p>
					</aside>
				</section> -->
				<section>
					<h2>Treat data as Immutable</h2>
					<ul>
						<li class="fragment">Immutable is not Mutable</li>
						<li class="fragment">Not changeable</li>
						<li class="fragment">number, string, boolean are immutable</li>
						<!-- <li class="fragment">Objects, arrays are mutable</li> -->
						<li class="fragment">Mutation has side effect</li>
						<li class="fragment">Less changes means less things to keep track</li>
						<!-- <li class="fragment">There are libraries to fix this issue <a href="">immutable</a></li> -->
					</ul>
					<aside class="notes">
						<p>string is immutable...you don't feel it as compiler takes care of it</p>
					</aside>
				</section>
				<section>
					<h2>Global Mutable State</h2>
					<img src="images/global-mutable-state.png" alt="">
					<p>Immutability creates simpler and safer code.</p>
					<br>
					<br>
					<p><small>read <a href="https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db">Programmer needs limit</a></small></p>
					<aside class="notes">
						<p>Did you ever wonder why most solutions to program glitches are fixed by <strong>rebooting your computer</strong> or restarting the offending application? That’s because of state. The program has corrupted its state.</p>
						<p>One obvious benefit is that if you have access to a value in your program, you only have read access, which means that
							no one else can change that value. Even you. So no accidental mutations.</p>
						<p>Also, if your program is multi-threaded, then no other thread can pull the rug out from under you. That value is constant
							and if another thread wants to change it, it’ll have create a new value from the old one.</p>
					</aside>
				</section>
				<section>
					<h2>Programming vs Math</h2>
					<pre class="hljs" data-trim><code>
var x = 1;
x = x + 1;
					</code></pre>
					<ul>
						<li class="fragment">It's permitted in Imperative Programming</li>
						<li class="fragment">In math, x can never be equal to x + 1</li>
						<li class="fragment">In functional programming, x = x + 1 is illegal</li>
						<li class="fragment">There are <strong class="danger">no variables</strong> in Functional Programming</li>
						<li class="fragment">Stored values are still called variables because of history but they are constants</li>
						<li class="fragment">Once x takes on a value, it’s that value for life</li>
					</ul>
					<aside class="notes">
						<p>Don’t worry, x is usually a local variable so its life is usually short. But while it’s alive, it can never change.</p>
					</aside>
				</section>
				<section>
					<blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						&ldquo;HOW THE HELL AM I SUPPOSED TO DO ANYTHING WITHOUT VARIABLES?!&rdquo;
					</blockquote>
					<p class="fragment">Just create a new variable</p>
				</section>
				<!-- <section>
					<h2>Example</h2>
					<pre class="hljs"><code>
function addOneTOSum(y , z){
	const x = 1;
	return x + y + z;
}
					</code></pre>
					<ul>
						<li class="fragment">x is bound to the value of 1</li>
						<li class="fragment">It’s equal to 1 for the rest of its life.</li>
						<li class="fragment">Its life is over when the function exits</li>
					</ul>
				</section>
				<section>
					<h2>Two types of variable</h2>
					<br>
					<ol class="fragment">
						<li>Single valued</li>
						<li>Multi valued</li>
					</ol>
					<br>
					<br>
					<ul>
						<li class="fragment">Doesn't change value, rather create a new variable</li>
						<li class="fragment">If values in record changes, create a new copy</li>
						<li class="fragment">Leverage Uses data structure underneath it to make it efficient: <span class="danger">Research how</span></li>
					</ul>
					<aside class="notes">
						<p>Functional Programming deals with changes to values in a record by making a copy of the record with the values changed.
							It does this efficiently without having to copy all parts of the record by using data structures that makes this possible.
							Functional programming solves the single-valued change in exactly the same way, by making a copy of it. Oh, yes and
							by not having loops.</p>
					</aside>
				</section>
				<section>
					<h2>Immutability in JS</h2>
					<pre class="hljs javascript"><code>
const a = 1;
a = 2; // will throw error
					</code></pre>
					<pre class="hljs javascript"><code data-trim>
const a = {
    x: 1,
    y: 2
};

a = {};  // will throw error

a.x = 2; // NO EXCEPTION!
					</code></pre>
					<p class="fragment">Avoid Object and array mutation</p>
					<p class="fragment"><code>Object.freeze</code> only freezes one level down</p>
					<p><small>Use: <a href="https://facebook.github.io/immutable-js/"> Immutable.js</a></small></p>
					<aside class="notes">
						<p>Here a is defined to be a constant and therefore cannot be changed once set. This is why a = 2 throws an exception</p>
						<p>The problem with const in JavaScript is that it doesn’t go far enough. The following example illustrates its limits:</p>
						<p>Notice how a.x = 2 does NOT throw an exception. The only thing that’s immutable with the const keyword is the variable
							a. Anything that a points to can be mutated.</p>
						<p>Unfortunately, we can only do so via a library called Immutable.js. This may give us better immutability but sadly,
							it does so in a way that makes our code look more like Java than JavaScript.</p>
					</aside>
				</section>-->
				<section>
					<h2>Hold on</h2>
					<p class="danger fragment">Loop needs variable</p>
					<p class="fragment">for, while, do while, etc.</p>
					<pre class="hljs fragment"><code>
var sum = 0;
for (var i = 1; i <= 10; ++i){
  sum += i;
}
console.log(sum); // prints 55
					</code></pre>
					<blockquote class="fragment">
						“WHAT NO VARIABLES AND NOW NO LOOPS?! I HATE YOU!!!”
					</blockquote>
				</section>
				<!-- <section>
					<h2>Looping in JavaScript</h2>
					<pre class="hljs javasript"><code>
var sum = 0;
for (var i = 1; i <= 10; ++i){
	sum += i;
}
console.log(sum); // prints 55
					</code></pre>
					<pre class="fragment hljs javascript"><code>
function sumRange(start, end, sum) {
    if (start > end)
        return sum;
    return sumRange(start + 1, end, sum + start)
}
console.log(sumRange(1, 10, 0)); // prints 55
					</code></pre>
					<aside class="notes">
						<h2>Two ways to lopping in javaScript</h2>
						<p>Notice how recursion, the functional approach, accomplishes the same as the for loop by calling itself with a new start
							(start + 1) and a new accumulator (acc + start). It doesn’t modify the old values. Instead it uses new values calculated
							from the old.</p>
						<p>You’re probably thinking that for loops are easier to understand. While that’s debatable and more likely an issue of
							familiarity, non-recursive loops require Mutability, which is bad.</p>
					</aside>
				</section> 
				<section>
					<h1>Looping</h1>
					<img style="height:450px;" src="images/loop2.jpg" alt="">
				</section>-->
				<section>
					<h2>Iterate over lists</h2>
					<pre class="hljs javascript"><code data-trim>
let tasks = ['write code', 'drink coffee', 'hide from manager'];
const lengths = tasks.map(word => word.length);
console.log(lengths); // [10, 12, 17]</code> </pre>
					<pre class="hljs fragment"><code data-trim>
const getLength = word => word.length;

tasks.map(getLength);
meals.map(getLength);
					</code> </pre>
					<pre class="fragment javascript"><code class="hljs" data-trim>
const doubleIt = x => x*2;

tasks.map(getLength).map(doubleIt);
					</code></pre>
					<br>
					<p><small><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">use map</a></small></p>
					<aside class="notes">
						<h2>You focus on functionality</h2>
						<ul>
							<li>declare far fewer variables</li>
							<li class="">Map takes a function</li>
							<li class="">And a collection of items</li>
							<li class="">It makes a new, empty collection</li>
							<li class="">runs the function on each item in the original collection</li>
							<li class="">inserts each return value into the new collection</li>
							<li class="">It returns the new collection</li>
						</ul>
						<h2>Reuse and chain</h2>
					</aside>
				</section>
				<section>
					<h2>Filter</h2>
					<pre class="hljs javascript"><code data-trim>
const numbers = [1, 2, 3, 4];
let newNumbers = [];

for(let i = 0; i < numbers.length; i++) {
    if(numbers[i] % 2 !== 0) {
        newNumbers[i] = numbers[i] * 2;
    }
}

console.log(newNumbers); // [2, 6]
					</code></pre>
					<pre class="hljs fragment"><code data-trim>
const numbers = [1, 2, 3, 4];
const odd = n => n % 2;
const doubleIt = x => x * 2;

const newNumbers = numbers.filter(odd).map(doubleIt);
					</code></pre>
					<br>
					<p><small>Ref: <a href="http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/">map, filter, reduce</a></small></p>
					<aside class="notes">
						<h2>Taking odd numbers and then double</h2>
					</aside>
				</section>
				<!--  <section>
					<h2>Reduce</h2>
					<ul>
						<li class="fragment">Reduce (aka: fold, accumulate)</li>
						<li class="fragment">Takes a reducer function and an initial value</li>
						<li class="fragment">returns the accumulated value</li>
					</ul>
					<br>
					<pre class="hljs javascript fragment"><code data-trim>
const numbers = [0, 1, 2, 3];

const sum = numbers.reduce(function(acc, val) {
  return acc + val;
}, 0);
					</code></pre>
					<pre class="hljs javascript fragment"><code data-trim>
const numbers = [0, 1, 2, 3];
const accumulator = (num, sum) => num + sum;

const sum = numbers.reduce(accumulator, 0);

console.log(sum);
					</code></pre>
					<br>
					<p><small>ref: <a href="https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d">reduce</a></small></p>
					<p><small>ref: <a href="http://raganwald.com/2017/04/30/transducers.html">transducer</a></small></p>
					<aside class="notes">
						<p>commonly used in functional programming that lets you iterate over a list, applying a function to an accumulated value
							and the next item in the list, until the iteration is complete and the accumulated value gets returned. Many useful
							things can be implemented with reduce. </p>
						<p>Reduce takes a function and a collection of items. It returns a value that is created by combining the items.</p>
					</aside>
				</section>
				<section>
					<h2>Reduce is very useful</h2>
					<pre class="hljs javascript"><code>
var list1 = [[0, 1], [2, 3], [4, 5]];
var list2 = [0, [1, [2, [3, [4, [5]]]]]];

const flatten = arr => arr.reduce((acc, val) =>
	acc.concat(Array.isArray(val) ? flatten(val) : val), []);

flatten(list1); // returns [0, 1, 2, 3, 4, 5]
flatten(list2); // returns [0, 1, 2, 3, 4, 5]
					</code></pre>
				</section> -->
				<section>
					<h2>Why map, filter, reduce</h2>
					<ul>
						<li class="fragment">Structure for looping always same</li>
						<li class="fragment">Map, filter, reduce take care of the repeating parts</li>
						<li class="fragment">Reduce typing- reduce chances of error</li>
						<li class="fragment">Focus on the important parts of the iteration: <strong>the operation</strong> </li>

					</ul>
					<aside class="notes">
						<li class="">It’s throwing some of the transformations away. It’s combining the remainder into a single output.</li>
					</aside>
				</section>
				<section>
					<h2>Understand Immutability</h2>
					<ul>
						<li>Think of Immutable data as a value (such as a number)</li>
						<li>A number never changes. </li>
						<li class="fragment">The number 7, is always 7</li>
						<li class="fragment">If you add 1 to 7 you get a new value: 8</li>
						<li class="fragment">It doesn’t change 7 itself </li>
					</ul>
					<br>
					<br>
					<p><small>Use: <a href="http://untangled.io/immutable-js-an-introduction-with-examples-written-for-humans/"> Human readable example in Immutable.js</a></small></p>
					
					<aside class="notes">
						<p>We can add an item to our collection, but that doesn’t change the original collection itself. </p>
					</aside>
				</section>
				
				<section>
					<p>Basic Concept-3</p>
					<h2>Data is Immutable</h2>
				</section>
			</section>
			<section>
				<section>
					<h1>Summary 1</h1>
				</section>
				<section>
					<h2>So far</h2>
					<ul>
						<li class="fragment">Functional programming means: a lot functions</li>
						<li class="fragment">Not just functions but <strong>pure functions</strong></li>
						<li class="fragment">With only one ground rule: <strong class="danger">No side effect</strong></li>
						<li class="fragment">Avoid shared state, mutable data, and side-effects</li>
						<li class="fragment">Immutable: No variable, only constant</li>
						<li class="fragment">No looping: use map, filter, reduce</li>
						<!-- <li class="fragment">Give repeating tasks to the compiler</li> -->
					</ul>
					<br>
					<br>
					<!-- <ul>
						<li class="fragment">Become more concise, more predictable way of thinking</li>
					</ul> -->
					<aside class="notes">
						<p>instead of creating a for-loop with an iterator variable and marching through an array doing something to each cell</p>
						<h2>So, we learn the basic</h2>
						<p>Now drive into common patterns in Functional Programming</p>
					</aside>
				</section>
				<section>
					<h2>Three basic Rules</h2>
					<ol>
						<li class="fragment">No Side Effect</li>
						<li class="fragment">Function is first class citizen</li>
						<li class="fragment">Data is Immutable</li>
					</ol>
				</section>
				<section>
					<h2>Find the napper</h2>
					<img style="height: 400px;" src="images/nap.jpg">
					<br>
					<ul>
						<li class="fragment">Who was in the image "Fully Lost?"</li>
					</ul>
				</section>
				<section>
					<img src="images/lost4.jpg" alt="">
				</section>
			</section>
			<section>
				<h1>Patterns and Techniques</h1>
				<p>Used in Functional Programming</p>
				<aside class="notes">
					<p>Now I will talk about few populer <strong>patterns and Technniques</strong> used in functional programming</p>
				</aside>
			</section>
			<section>
				<section>
					<h1>Warning</h1>
				</section>
				<section>
					<h2 class="danger"><strong>WARNING</strong></h2>
					<ul>
						<li class="">Everything you know has a obscure name</li>
						<li class="fragment">There are <strong>harder alternatives</strong> to simple things</li>
						<li class="fragment">Nerd means living dictionary of <strong>Jargons</strong></li>
					</ul>
					<!-- <img class="fragment" src="images/warning.png"></img> -->
				</section>
			</section>
			<section>
				<section>
					<h1>Composition</h1>
					<img src="images/composition1.jpeg" alt="">
				</section>
				<section>
					<p>f(x) = 2x + 3</p>
					<p class="fragment">f(2) = ?</p>
					<pre class="fragment"><code data-trim>
f(2) = 2 * 2 + 3
     = 4 + 3
     = 7
					</code></pre>
					<p class="fragment">g(x) = x <sup>2</sup> + 1</p>
					<p class="fragment">g(2) = ?</p>
					<pre class="fragment"><code data-trim>
						g(2) = 2 * 2 + 1
						     = 4 + 1
						     = 5
					</code></pre>
					<p class="fragment">What is the value of f(g(x)) or f(g(2))?</p>
					<pre class="fragment"><code data-trim>
f(g(2)) = f(5)
        = 2 * 5 + 3
        = 10 + 3
        = 13
					</code></pre>
					<aside class="notes">
						<p>f(2)</p>
						<p>g(2)</p>
					</aside>
				</section>
				<section>
					<h2>Make this complicated</h2>
					<ul>
						<li>What you saw as f(g(x))</li>
						<li class="fragment">f ∘ g (read as f of g)</li>
						<li class="fragment">f after g</li>
						<li class="fragment">calling f after calling g with x</li>
						<li class="fragment">or simply: <strong>f composed with g</strong></li>
					</ul>
					<p class="fragment">g(x) inside f(x)...inside executes first</p>
					<br>
					<br>
					<p><small>Khan Academy: <a href="https://www.khanacademy.org/math/algebra2/manipulating-functions/funciton-composition/v/function-composition">function composition</a></small></p>
				</section>
				<section>
					<h2>Wait! it's not new</h2>
					<pre class="fragment"><code>
const mult5 = x => x * 5;
const add10 = x => x + 10;
					</code></pre>
					<pre class="fragment hljs"><code>
const mult5AfterAdd10 = x => mult5(add10(x));
					</code></pre>
					<h4 class="fragment">f(g(x))</h4>
					<aside class="notes">
						<p>What we’ve done in this case is manually compose these two functions together in a particular order. We created a new function that first assigns the value being passed to a holder variable, then updates the value of that variable by executing the first function, and then the second function, and finally returns the value of that holder.</p>
					</aside>
				</section>
				<section>
						<h2>Function Composotion</h2>
					<pre class="fragment1"><code data-trim>
						var compose = function(f, g) {
						  return function(x) {
						    return f(g(x));
						  };
						};
					</code></pre>
					<pre class="fragment"><code class="hljs javascript " data-trim>
const mult5 = x =>  x * 5;
const add10 = x =>  x + 10;

const mult5AfterAdd10 = compose(add10, mult5);
mult5AfterAdd10(5); //35
					</code></pre>
					<p class="fragment">executes <strong>right to left</strong></p>
					<p class="fragment"> Direction matters</p>
					<br>
					<p><small>ref: <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html#functional-husbandry">Coding by composing</a></small></p>
					<aside class="notes">
						<p>Though left to right would be easy to read in English</p>
						<p><strong>Why Right to left:</strong>Pass in all of the configuration first, and pass the value(s) to be operated on last. Because of this, it makes the most sense to define our compose function to read in its arguments and apply them from right to left.</p>
						<p>The composition of two functions returns a new function. This makes perfect sense: composing two units of some type (in this case function) should yield a new unit of that very type. You don't plug two legos together and get a lincoln log. There is a theory here, some underlying law that we will discover in due time.</p>
						In our definition of compose, the g will run before the f, creating a right to left flow of data.
					</aside>
				</section>
				<!--<section>
					<h2>Another Example</h2>
					<pre><code>
const split = str => str.split(' ');
const length = itmes => items.length;

const wordCount = compose(length, split);
wordCount('There are seven words in this sentence'); //7
					</code></pre>
					<ul>
						<li class="fragment">Partially apply split first</li>
						<li class="fragment">While performing split we are waiting for length</li>
						<li class="fragment">split does it works and then pass it to length</li>
						<li class="fragment">Curried function is partially applied</li>
					</ul>
					<aside class="notes">
						<p>Giving you another example so that you keep it in your head</p>
					</aside>
				</section> -->
				<section>
					<h2>Elm example</h2>
					<pre class="hljs elm"><code>
add10 value =
    value + 10
mult5 value =
    value * 5
mult5AfterAdd10 value =
    (mult5 << add10) value
					</code></pre>
					<pre class="hljs elm fragment"><code>
f x = (g << h << s << r << t) x
					</code></pre>
					<aside class="notes">
						<p>Note the parentheses in mult5AfterAdd10, i.e. (mult5
							<< add10). They are there to make sure that the functions are composed first before applying value.</p>
								<p>Here x is passed to function t whose result is passed to r whose result is passed to s and so on. If you did something
									similar in JavaScript it would look like g(h(s(r(t(x))))), a parenthetical nightmare</p>
					</aside>
				</section>
				<section>
					<h2> Why Composition</h2>
					<ul>
						<li>Put multiple functions together to get one function</li>
						<li>Moves right to left</li>
						<li class="fragment">Each step sequentially processing it before handing it to the next</li>
						<li class="fragment">Encourages factoring (breaking apart) for maintainability and code reuse</li>
						<li class="fragment">Cleans up nesting</li>
					</ul>
					<aside class="notes">
						<p>Since you can put together...to compose... you can break apart next</p>
						<p>The ability to easily compose functions encourages factoring (breaking apart) functions for maintainability and code reuse. More generally, big systems might be built by composing whole programs.</p>
						<p>function composition applies to functions that operate on a finite amount of data, each step sequentially processing it before handing it to the next.</p>
					</aside>
				</section>
				
			</section>
			<section>
				<section>
					<h1>Currying</h1>
					<img style="height: 300px;" src="images/curry.png" alt="">
					<br>
					<p><small>Ref: <a href="https://en.wikipedia.org/wiki/Haskell_Curry">Haskell Brooks Curry</a></small></p>
					<aside class="notes">
						<h3>Number two of our</h3>
					</aside>
				</section>
				<section>
					<h3>Currying</h3>
					<ul>
						<li class="fragment">Call a function with one parameter at a time</li>
						<li class="fragment">Returns a function that takes second parameter</li>
						<li class="fragment">arguments are taken by a series of one-argument</li>
						<pre class="fragment javascript"><code data-trim>
const sum3 = (x, y, z) => x + y + z;
sum3(1,2,3); //6
						</code></pre>
						<pre class="fragment"><code data-trim>
function currySum3(x){
  return function (y){
    return function (z){
      return x + y + z;
    }
  }
}

const currySum3 = x => y => z => x + y + z;
currySum3(1)(2)(3); //= 6
						</code></pre>
					</ul>
					<blockquote class="hide">
						<p>A Curried Function is a function that only takes a single parameter at a time.</p>
					</blockquote>
					<br>
					<p><small>Ref: <a href="https://hughfdjackson.com/javascript/why-curry-helps/">Why Curry Helps</a> and
						<a href="https://github.com/dominictarr/curry">Curry JS</a></small></p>
					<aside class="notes">
						<h2>The concept is simple: </h2>
						<p>The reason that we were having problems composing mult5 and add (in ) is because mult5
							takes 1 parameter and add takes 2.</p>
						<p>We can solve this easily by just restricting all functions to take only 1 parameter.</p>
						<p>Trust me. It’s not as bad as it sounds.</p>
						<p>We simply write an add function that uses 2 parameters but only takes 1 parameter at a time. Curried functions allow
							us to do this.</p>
						<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">part4</a></p>
					</aside>
				</section>
				<!-- <section>
					<h3>Curried Function</h3>
					<pre class="fragment"><code data-trim>
function sum3(x){
	return function (y){
		return function (z){
			return x + y + z;
		}
	}
}
					</code></pre>
					<pre class="hljs fragment javascript"><code>
currySum3(1)(2)(3); //= 6
					</code></pre>
					<pre class="fragment javascript"><code>
const first = sum3(1);
const second = first(2);
const third = second(3);
console.log(third); // 6
					</code></pre>
					<br>
					<p><small>Ref: <a href="https://medium.com/@kevincennis/currying-in-javascript-c66080543528">Currying in JS</a></small></p>
					<aside class="notes">
						<p>In detail, the add function takes a single parameter, x, and returns a function that takes a single parameter, y, which
							will ultimately return the result of adding x and y.</p>
						<p>This will let us give add its first parameter before we compose it with mult5. Then when mult5AfterAdd10 is called,
							add will get its second parameter.</p>
						<p>This version of add is a function that takes one parameter now and then another one later.</p>
					</aside>
				</section> -->
				<section>
					<h2>Why Curry?</h2>
					<pre class="hljs javascript"><code data-trim>
const modulo = divisor => dividend => dividend % divisor;

modulo (3, 9); //0
					</code></pre>
					<pre class="fragment hljs javascript"><code data-trim>
const isOdd = modulo(2);

isOdd(6); //0

isOdd(5); //1
					</code></pre>
					<ul>
						<li class="fragment">Make reusable generic function</li>
						<li class="fragment">Build new function by applying args</li>
						<li class="fragment">Partially applied for higher order function</li>
						<li class="fragment">Make types "line up" for composition</li>
					</ul>
					<p><small>Ref: <a href="https://softwareengineering.stackexchange.com/q/185585">advantages of currying</a></small></p>
					<aside class="notes">
						<p>We created functionality by giving functionality</p>
					</aside>
				</section>
				<!--<section>
					<h2>Promise is currying</h2>
					<p class="dangser">Is pormise is curry?</p>
					<pre class="fragment"><code data-trim>
						fetchFromServer()
						    .then(JSON.parse)
						    .then(get('posts'))
						    .then(map(get('title')))
					</code></pre>
					<p><small><a href="https://github.com/learn-javascript-courses/javascript-questions/issues/7">Is Currying Advantageours</a></small></p>
				</section>
				 <section>
					<h2></h2>
					<p>Now we can use this version of add to build a working version of mult5AfterAdd10:</p>
					<pre><code>
var compose = (f, g) => x => f(g(x));
var mult5AfterAdd10 = compose(mult5, add(10));
					</code></pre>
					<p>The compose function takes 2 parameters, f and g. Then it returns a function that takes 1 parameter, x, which when called
						will apply f after g to x.</p>
					<p>So what did we do exactly? Well, we converted our plain old add function into a curried version. This made add more
						flexible since the first parameter, 10, can be passed to it up front and the final parameter will be passed when mult5AfterAdd10
						is called.</p>
				</section>
				<section>
					<h2>Add more solid example</h2>
				</section>
				<section>
					<h2>Currying and Refactoring</h2>
					<p>Another time currying shines is during refactoring when you create a generalized version of a function with lots of
						parameters and then use it to create specialized versions with fewer parameters.</p>
					<p>For example, when we have the following functions that put brackets and double brackets around strings:</p>
				</section> -->
				<section>
					<h2>Currying and Composition</h2>
					<pre><code>
const f = a => b => c => d => a + b + c + d
f(1)(2)(3)(4); // returns 10
</code></pre>
					<pre class="fragment hljs"><code>
const f = R.curry((a, b, c, d) => a + b + c + d);
f(1, 2, 3, 4); // returns 10
f(1, 2)(3, 4); // also returns 10
f(1)(2)(3, 4); // also returns 10
</code></pre>
					<br>
					<br>
					<p><small>Ref: <a href="http://ramdajs.com/">Ramada JS</a></small></p>
					<aside class="notes">
						<p>Too much parenthesis... might confuse you and make you cry.</p>
						<p>a framework named Ramada will rescue you</p>
						<p>The function definition isn’t much better but we’ve eliminated the need for all those parenthesis. Notice that we can
							apply as many or as few parameters as we want each time we invoke f.</p>
					</aside>
				</section>
				<!-- <section>
					<h2>Ramada JS</h2>
					<pre class="hljs"><code>
//add old code here
</code></pre>
					<pre class="fragment hljs"><code>
const add = R.curry((x, y) => x + y);
const mult5 = value => value * 5;
const mult5AfterAdd10 = R.compose(mult5, add(10));
</code></pre>
					<pre class="fragment"><code>
const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));
</code></pre>
					<aside class="notes">
						<p>Ramda has a lot of helper functions for doing these sorts of things, e.g. R.add and R.multiply, which means we can
							write less code:</p>
					</aside>
				</section> -->
			</section>
			<section>
				<section>
					<h1>Point Free</h1>
					<img src="images/free.png" alt="">
					<aside class="notes">
						<h3>Third concept</h3>
					</aside>
				</section>
				<section>
					<h2>Point Free Programming</h2>
					<ul>
						<li>Also known as <strong>Tacit Programming</strong></li>
						<li class="fragment">function definition does not include arguments</li>
						<li class="fragment">Uses combinators and function composition instead of variable</li>
						<li class="fragment">For simplicity you can think point is argument. </li>
						<li class="fragment">Hence point free is argument free</li>
					</ul>
					<p class="fragment">You use point free: to focus on how rather than what</p>
					<br>
					<p><small>Ref: <a href="http://randycoulman.com/blog/2016/06/21/thinking-in-ramda-pointfree-style/">Think point free</a></small></p>
					<aside class="notes">
						<p>For simplicity you can think point is argument. Hence point free is argument free</p>
						<h2>Why point free</h2>
						<ul>
							<li>You focus on how rather than what</li>
						</ul>
					</aside>
				</section>
				<section>
					<h2>Point free notation</h2>
					<pre class="fragment"><code data-trim>
const toUpperCase = str => str.toUpperCase();
const head =  str => str[0];
const compose = (f, g)  => x => f(g(x));

//not point free because we mention the data: name
const initials = function(name) {
 return name.split(' ').map(compose(toUpperCase,head)).join('. ');
};
					</code></pre>
					<pre class="fragment"><code>
initials("that js dude");
// 'T. J. D.'					
					</code></pre>
					<pre class="fragment"><code data-trim>
//point free
const initials = compose(join('. '),
                    map(compose(toUpperCase, head)), split(' '));

					</code></pre>
					<br>
					<!-- <p class="danger">Why would you use point free?</p> -->
					<p><small> Ref <a href="http://lucasmreis.github.io/blog/pointfree-javascript/">this</a> and <a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch5.html#pointfree">this as well</a> or <a href="http://lucasmreis.github.io/blog/pointfree-javascript/">this</a>
					</small></p>
					<aside class="notes">
						<p> defining functions without ever making direct reference to their arguments.</p>
					</aside>
				</section>
				<!-- <section>
					<h2>Two parameters pain</h2>
					<pre class="hljs"><code>
add x y =
    x + y
mult5 value =
    value * 5
					</code></pre>
					<pre><code>
var mult5AfterAdd10 = mult5(add(10)); // this doesn't work
						</code></pre>
					<pre class="hljs fragment"><code>
var mult5AfterAdd10 = y => mult5(add(10, y)); // not point-free
						</code></pre>
						<p class="fragment highlight-red">It's not throwing error</p>
						<p>Read more, research more about it</p>
				</section> -->
			</section>
			<!-- <section>
				<section>
					<h1>Recursion</h1>
					<p>Put inside tail call opt</p>
				</section>
				<section>
					<h2>Recursion</h2>
					<p>Recursion is heavily used in functional programming as it is the canonical and often the only way to iterate. Functional
						language implementations will often include tail call optimization to ensure that heavy recursion does not consume excessive
						memory.
					</p>
					<p>check this slide: <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-30">here</a></p>
					<pre><code data-trim>
						//1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...
						function fibonacci(num) {
						  if (num <= 1) return 1;
						  return fibonacci(num - 1) + fibonacci(num - 2);
						}
					</code></pre>
					<pre class="fragment"><code data-trim>
					</code></pre>
					<aside class="notes">
					<p>There are many reasons that functional programmers prefer recursion, but one very simple one is that recursive functions are often much more elegant than their iterative cousins. It's easier to reason about them.</p>
					<p>Unfortunately, they often don't perform as well. All the overhead of creating stack contexts for function calls tends to add up. But certain kinds of recursive calls can be easily optimized.</p>
					</aside>
				</section>
				<section>
					<p><small>Ref: <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-34">Tail call formulation</a></small></p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Tail call Optimization</h1>
					<img style="height:300px;" src="images/tail3.jpg" alt="">
					<aside class="notes">
						<h3>Number four of moderate level concept</h3>
					</aside>
				</section>
				<section>
					<h2>Tail call optimization</h2>
					<ul>
						<li>A tail call is a function call that is the last action of a function</li>
						<li class="fragment">Smart compiler recognizes tail calls and reuses the same call frame</li>
						<li class="fragment">When calling function will simply return the value that it gets from the called function</li>
						<li class="fragment">Optimized to use constant stack space</li>
						<li class="fragment">The most common use is tail-recursion</li>
						<li class="fragment">Can happen for non-recursive case as well</li>
					</ul>
					<!-- <p>if you write recursive functions with tail calls, the limits of the call stack will never be exceeded by them as it will reuse the same frame over and over</p> -->
					<br>
					<br>
					<p><small>Ref: <a href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization">Tail call optimization</a></small></p>
					<aside class="notes">
						<p><strong>tail-recursive</strong> means main recursive calls it makes are in tail positions.</p>
						<p>Tail-call optimization is where you are able to avoid allocating a new stack frame for a function because the calling function will simply return the value that it gets from the called function. The most common use is tail-recursion, where a recursive function written to take advantage of tail-call optimization can use constant stack space.</p>
						<p><strong>A tail call is a subroutine call performed as the final action of a procedure</strong></p>
						<p>A tail call is a function call that is the last action of a function. Tail call optimization is when the language compiler recognizes tail calls and reuses the same call frame for them. This means that if you write recursive functions with tail calls, the limits of the call stack will never be exceeded by them as it will reuse the same frame over and over.</p>
					</aside>
				</section>
				<section>
					<h2>What is a tail call?</h2>
					<pre><code>
//Both f() and g() are in tail position
const a = x => x ? f() : g();
					</code></pre>
					<pre class="fragment hljs javascript"><code>
// g() is in a tail position
const a = () => f() || g();

const a = () => f() && g();
					</code></pre>
					<p><small>Ref: <a href="http://2ality.com/2015/06/tail-call-optimization.html">Tail call optimization ES6</a></small></p>
				</section>
				<section>
					<h2>fibonacci</h2>
					<pre><code>
function fib(n) {
  if (n <= 1){
    return n;
  } else {
    return fib(n-1) + fib(n - 2);
  }
}
					</code></pre>
				</section>
				<section>
					<img src="images/fibo.png" alt="">
					<ul>
						<li class="fragment">Algorithm has O(n) memory complexity</li>
						<li class="fragment">Calculating fib(1) the callstack has 5 frames on it </li>
						<li class="fragment">Each remembering how to combine with the other calls</li>
					</ul>
				</section>
				<section>
					<pre><code>
function fibIterRecursive(n, a, b){
  if (n === 0) {
    return b;
  } else {
    return fibIterRecursive(n-1, a + b, a);
  }
};

function fib(n){
  return fibIterRecursive(n, 1, 0);
}
					</code></pre>
					<ul>
						<li class="fragment">return invocation of a function</li>
						<li class="fragment">that function does not need to access any of the current local variables</li>
						<li class="fragment">Then ES6 strict mode will optimize that call by reusing the stack frame</li>
					</ul>
					<aside class="notes">
						<p class=""><strong>In ES6:</strong> if the last thing that happens before the return statement is the invocation of a function which does not need to access any of the current local variables, the interpreter specified by ES6 will optimize that call by reusing the stack frame.</p>
					</aside>
				</section>
				<!-- <section>
					<pre><code>
const factorial = function ( n, base ) {
  if ( n === 0 ) {
    return base;
  }
  base *= n;
  return factorial( n - 1, base );
};

console.log(factorial( 10, 1 )); // 3628800
					</code> </pre>
				</section>
				<section>
					<p><a href="http://2ality.com/2015/06/tail-call-optimization.html">read this</a></p>
					<p><a href="http://benignbemine.github.io/2015/07/19/es6-tail-calls/">read this</a></p>
					<p><a href="https://taylodl.wordpress.com/2013/06/07/functional-javascript-tail-call-optimization-and-trampolines/">or this</a></p>
				</section>
				<section>
					<pre><code class="hljs" data-trim contenteditable>
						'use strict';
						function fibonacci(len) {
						  function recur(len, origLen, oldVal, newVal) {
						    if(len == origLen)
						      return oldVal + newVal;

						    return recur(len + 1, origLen, newVal, oldVal + newVal);
						  }

						  return recur(1, len, 0, 1);
						}

						console.log(fibonacci(27));
					</code></pre>
				</section>
				<section>
					<p>also look at this slide: <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-34">here</a></p>
				</section>
				<section>
					<p><a href="http://wiki.c2.com/?TailCallOptimization">another</a></p>
				</section> -->
			</section>
			<!-- <section>
				<h1>Trampolines in JavaScript</h1>
				<a href="http://raganwald.com/2013/03/28/trampolines-in-javascript.html">here</a>
			</section>
			<section>
				<section>
					<h2>Execution order</h2>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">Not so good here: but you can use it</a></p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Pipelines</h1>
					<img src="images/pipeline.JPG" alt="">
					<aside class="notes">
						<h3>Fift thing</h3>
					</aside>
				</section>
				<section>
					<h2>Collection Pipelines</h2>
					<ul>
						<li class="fragment">A  programming pattern</li>
						<li class="fragment">Lays out a sequence of operations</li>
						<li class="fragment">Feed output of one operation into the next</li>
						<li class="fragment">Common in FP and OOP with Lambdas</li>
						<li class="fragment">Put common operations (map, filter, reduce) together</li>
					</ul>
					<br>
					<br>
					<p><small>ref: <a href="https://martinfowler.com/articles/collection-pipeline/">Martin Fowler: Collection pipelines</a></small></p>
					<aside class="notes">
						<p>Each operation takes a collection as an input and emits another collection (except the last operation, </p>
						<p>The individual operations are simple, but you can create complex behavior by stringing together</p>
						<p>Collection pipelines are a programming pattern where you organize some computation as a sequence of operations which compose by taking a collection as output of one operation and feeding it into the next.</p>
						<p>(Common operations are filter, map, and reduce.)</p>
						<p>  This pattern is common in functional programming, and also in object-oriented languages which have lambdas. </p>
						<p>This article describes the pattern with several examples of how to form pipelines, both to introduce the pattern to those unfamiliar with it, and to help people understand the core concepts so they can more easily take ideas from one language to another.</p>
					</aside>
				</section>
				<section>
					<h2>Pipelines in Unix</h2>
					<p class="">
						 find all wiki that mention "nosql" in the text
					</p>
					<pre class="fragment hljs unix"><code>
grep -l 'nosql' wiki

grep -l 'nosql' wiki/* | xargs wc -w
					</code></pre>
					<pre class="fragment hljs"><code>
grep -l 'nosql' wiki/* | xargs wc -w | sort -nr
					</code></pre>
					<pre class="fragment hljs"><code class="hljs">
grep -l 'nosql' wiki/* | xargs wc -w | sort -nr | head -4 | tail -3
					</code></pre>
					<br>
					<p><small>ref: <a href="https://martinfowler.com/articles/collection-pipeline/">Martin Fowler: Collection pipelines</a></small></p>
					<aside class="notes">
						<li class="">Used in unix...varies in other Programming</li>
						<ol>
							<li>all wiki entries that mention "nosql" in the text.</li>
							<li>Then want to find out <strong>how many words</strong> are in each entry</li>
							<li>and perhaps sort them by their word count</li>
							<li>and then just print the top 3 (removing the total)</li>
						</ol>
					</aside>
				</section>
				<section>
					<h2>Pipeline in JS</h2>
					<pre class="hljs javascript"><code data-trim>
const addOne = x => x + 1;
const square = x => x * x;
const minusTwo = x => x - 2;

// Not reusable
minusTwo(square(addOne(10)));
minusTwo(square(addOne(20)));
					</code></pre>
					<pre class="fragment hljs javascript"><code>
const someFormula = new Pipeline([ addOne, square, minusTwo ]);
someFormula.process(10);
someFormula.process(20)
					</code></pre>
					<pre class="fragment hljs javascript"><code>
// alternative approach
const someFormula = (new Pipeline()).pipe(addOne)
                                  .pipe(square)
                                  .pipe(minusTwo);
					</code></pre>
					<p><small>Ref: <a href="https://github.com/kamranahmedse/pipeline-js">pipeline JS</a></small></p>
					<aside class="notes">
						<p>If formula changes...now you can change one place...</p>
					</aside>
				</section>
				<section>
					<h2>ESNext Proposal</h2>
					<pre class="hljs javascript js es6"><code>
const doubleSay = str => str + ", " + str;

const capitalize  = str => str[0].toUpperCase() + str.substring(1);

const exclaim = str => str + '!';
					</code></pre>
					<pre class="fragment hljs javascript"><code>
let result = exclaim(capitalize(doubleSay("hello")));


let result = "hello" |> doubleSay |> capitalize |> exclaim;

//Hello, hello!
					</code></pre>
					<p><small>ref: <a href="https://github.com/gilbert/es-pipeline-operator">JS pipeline proposal</a></small></p>
				</section>
			</section>
			<!--<section>
				<section>
					<h2>Lazy Evaluation</h2>
					<img src="images/lazy1.jpg" alt="">
				</section>
				<section>
					<h2>Be Lazy</h2>
					<ul>
						<li class="fragment">Don’t do something until you absolutely have to</li>
						<li class="fragment">Be lazy and procrastinate as long as possible</li>
					</ul>
					<pre class="fragment"><code data-trim>
						large_list
						  .map{|e| slow_complex_method (e)}
						  .take(5)
					</code></pre>
					<br>
					<br>
					<p><small>Ref: at the bottom: <a href="https://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504">here</a> or <a href="https://martinfowler.com/articles/collection-pipeline/#Laziness">Laziness</a></small></p>
					<aside class="notes">
						<p>With such code, you would spend a lot of time evaluating slow_complex_method on lots of elements and then throw away all the results except the top 5. Laziness allows the underlying platform to determine that you only need the top five results, and then only to perform slow_complex_method on the ones that are needed.</p>
					</aside>
				</section>
				<section>
					<h2>Lazy Evaluation in JS</h2>
					<pre><code>
// Not lazy. immediately evaluates to 2
var value = 1 + 1

// Lazy. Evaluates to 2 when lazyValue is *invoked*
var lazyValue = () => 1 + 1
					</code></pre>
					<pre class="fragment hljs javascript"><code>
// Not lazy. Immediately evaluates to 3
var add = (x, y) => x + y
var result = add(1, 2)

// Lazy. Returns a thunk which *when evaluated* results in 3.
var addLazy = (x, y) => () => x + y;
var result = addLazy(1, 2)
					</code></pre>
					<p><small>Ref: <a href="https://hackernoon.com/lazy-evaluation-in-javascript-84f7072631b7">redux-thunk</a> and  <a href="http://stackoverflow.com/questions/38904865/meaning-of-lazy-evaluation-in-javascript">Good example</a></small></p>
					<aside class="notes">
						<p class="danger">Research: What is thunk</p>
					</aside>
				</section>
				<section>
					<pre><code>
function testArray(input) {
  return input
    .filter((el) => el % 2 === 0)
    .map((el) => el * 5)
    .reduce((total, next) => total + next, 0);
}
					</code></pre>
					<pre class="fragment"><code>
function testRx(input) {
  let value;

  Rx.Observable.from(input)
    .filter((el) => el % 2 === 0)
    .map((el) => el * 5)
    .reduce((total, next) => total + next, 0)
    .subscribe((result) => { value = result; });

  return value;
}
					</code></pre>
				</section>
				<section>
					<h2>Test setup for RxJS</h2>
					<pre><code>
const inputData = Array(1000000).fill(1).map(() => Math.floor(Math.random() * 10000));

function test(label, testFn, input) {
  const start = Date.now();
  const result = testFn(input);
  const end = Date.now();
  const seconds = parseFloat((end - start) / 1000).toFixed(2);
  console.log(`${label} took ${seconds}s and had result of ${result}`);
}

test('Array', testArray, inputData);
test('RxJS', testRx, inputData);
					</code></pre>
					<br>
					<p><small>Ref: <a href="https://youtu.be/TszoFCFydiM?t=13m41s">RxJS perf test</a></small></p>
				</section>
				<section>
					<p>Array took 0.14s and had result of 12498033630</p>
					<p class="fragment">RxJS took 0.08s and had result of 12498033630</p>
				</section>
				<section>
					<h2>lazy async</h2>
					<pre class="hljs javascript"><code>
// Not lazy
var callApi = spec => fetch(spec.url, spec.options);
var result = callApi({url: '/api', options: {}});

// Lazy
var callApiLazy = spec => () => fetch(spec.url, spec.options);
var result = callApiLazy({url: '/api', options: {}});
// result is a thunk that when evaluated will return a Promise ...
// which will be fulfilled when the network response is processed.
					</code></pre>
					<p class="fragment">Curry is not lazy</p>
					 <pre class="fragment hljs javascript"><code>
// Curried add (not lazy)
var add = x => y => x + y
var add3 = add(3)
var result = add3(7)  // Immediately evaluates to 10
					</code></pre>
				</section>
				<section>
					<h2>Debug Lazy function</h2>
					<p><small>Extra: <a href="http://stackoverflow.com/questions/1303794/how-is-debugging-achieved-in-a-lazy-functional-programming-language">Debug lazy function</a></small></p>
				</section>
			</section>-->
			<!-- <section>
				<section>
					<h1>Type annotation</h1>
				</section>
				<section>
					<h2></h2>
					<p>a type constructor is a generic type definition, which takes another type as a parameter.</p>
				</section>
			</section> -->
			<!-- <section>
				<section>
					<h1>Combinators</h1>
				</section>
				<section>
					<p>a function which builds program fragments from program fragments</p>
					<p><small>Ref: <a href="http://stackoverflow.com/questions/7533837/explanation-of-combinators-for-the-working-man">this</a> or <a href="https://softwareengineering.stackexchange.com/a/117575">this</a>or <a href="http://scalafp.com/book/functional-programming-is-like-unix-pipelines.html">at the bottom of this</a></small></p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Partial application</h1>
				</section>
				<section>
					<h2>Currying and partial application</h2>
					<ul>
						<li class="fragment">Currying is strict: always takes 1 parameter at a time</li>
						<li class="fragment">Partial application is not this strict</li>
						<li class="fragment">You can pass more than one parameter at a time</li>
					</ul>
					<br>
					<br>
				<p><small>Ref: <a href="http://www.datchley.name/currying-vs-partial-application/">here</a> or <a href="https://smthngsmwhr.wordpress.com/2012/10/22/higher-order-javascript-short-journey-into-the-land-of-functional-programming/#partial_application">this</a></small></p>
				<aside class="notes">
					<p>Currying is strict: a curried function always applied 1 parameter at a time. Partial application is not this strict.</p>
					<p>A curried function tends to be partially applied but a partially applied function does not have to be curried.</p>
				</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>Summary 2</h1>
				</section>
				<section>
					<h2>So far</h2>
					<ul>
						<li class="fragment">Compose puts functions together</li>
						<li class="fragment">Curry takes one argument at a time</li>
						<li class="fragment">Point free...doesn't take arguments</li>
						<li class="fragment">Partial application takes one or more</li>
						<li class="fragment">Tail call is a compiler magic</li>
						<!-- <li class="fragment">Lazy evaluation makes things faster</li> -->
					</ul>
					<aside class="notes">
						<p>Look at you...you have three names as well</p>
					</aside>
				</section>
				<section>
					<h2>Code reuse</h2>
					<ul>
						<li class="fragment">Code reuse sounds great but is difficult to achieve.</li>
						<li class="fragment">Make the code too specific and you can’t reuse it.</li>
						<li class="fragment">Make it too general and it can be too difficult to use in the first place</li>
						<li class="fragment">So what we need is a balance between the two, a way to make smaller</li>
					</ul>
				</section>
				<section>
					<h2>Find the napper</h2>
					<img style="height:350px;" src="images/lost3.JPG" alt="">
					<p class="fragment"><small>While cooking curry...how many people were adding spices?</small></p>
					<aside class="notes">
						<p>5</p>
					</aside>
				</section>
			</section>
			<!-- <section>
				<section>
					<h1>Give away</h1>
				</section>
				<section>
					<h2>7 ways to Propose</h2>
					<ol>
						<li class="fragment">We can Open Any <strong>JARS</strong> for you</li>
						<li class="fragment">We love to <strong>KISS</strong>(keep it simple, stupid)</li>
						<li class="fragment">We could give you <strong>PERL</strong> and <strong>RUBY</strong></li>
						<li class="fragment">We aren't afraid to <strong>COMMIT</strong></li>
						<li class="fragment">We are really good at <strong>getting rid of bugs</strong></li>
						<li class="fragment">We will never have a <strong>NULL</strong> moment</li>
						<li class="fragment">We could take you to the <strong>CLOUD</strong></li>
					</ol>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Category Theory</h1>
					<blockquote class="">In theory, there is no difference between theory and practice. But, in practice, there is.
					</blockquote>
				</section>
				<section>
					<h2>Category Theory</h2>
					<ul>
						<li class="fragment">Mathematical discipline in theoretical computer science</li>
						<li class="fragment">It has a wide range of applications</li>
						<li class="fragment">Concepts like Category, Functor, Monad, and others</li>
						<li class="fragment">Understanding Category Theory isn't a must to understand FP</li>
					</ul>
					<br>
					<br>
					<p><small>Ref: <a href="http://nikgrozev.com/2016/03/14/functional-programming-and-category-theory-part-1-categories-and-functors/">Category Theory</a></small></p>
					<p class="hide"><small><a href="https://cs.stackexchange.com/questions/3028/is-category-theory-useful-for-learning-functional-programming">Is is needed to learn Category theory to understand FP</a></small></p>
				</section>
				<section>
					<h4>Categories</h4>
					<img style="height:200px;" src="images/category.jpg" alt="">
					<ul>
						<li class="fragment"> A category consists of objects and arrows that go between them.</li>
						<li class="fragment">Arrows are known as morphisms. Morphisms can be thought of as functions.</li>
					</ul>
					<p><small>Ref: <a href="https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/">Category Theory for Programmers: Book</a></small></p>
					<p class="hide"><small>Ref: <a href="https://yogsototh.github.io/Category-Theory-Presentation/">Category THeory & Programming</a></small></p>
					<aside class="notes">
						<p>In a category, if there is an arrow going from A to B and an arrow going from B to C then there must also be a direct arrow from A to C that is their composition. This diagram is not a full category because it’s missing identity morphisms (see later).</p>
						<p>arrows, which are also called morphisms, as functions</p>
						<p>You have a function f that takes an argument of type A and returns a B. </p>
						<p></p>
					</aside>
				</section>
				<section>
					<img src="images/composition.png" alt="">
					<p class="fragment">For any group of connected objects, a -> b -> c, there must be a composition which goes directly from a -> c.</p>
					<!-- <li class="fragment">All objects in a category have identity arrows.</li> -->
				</section>
					<!-- <section>
						<h2>Functor Laws</h2>
						<ul>
							<li class="fragment">Categories have two important properties</li>
							<li class="fargment">Identity</li>
							<li class="fargment">Composition</li>
						</ul>
						<pre class="hljs fragment"><code>
	const f = [1, 2, 3];
	f.map(x => x); // [1, 2, 3]
							</code></pre>
							<p class="fragment">Functors must obey the composition law: F.map(x => f(g(x))) is equivalent to F.map(g).map(f).</p>
						<pre class="hljs fragment"><code>

						</code></pre>
						<aside class="notes">
							<h4>Identity</h4>
							<p>If you pass the identity function (x => x) into f.map(), where f is any functor, the result should be equivalent to
								(have the same meaning as) f:</p>
						</aside>
					</section> -->
					<section>
						<h4>Mathematicians vs Programmer</h4>
						<img src="images/translation.png" alt="">
						<img class="fragment" style="height:200px;" src="images/cat.png" alt="">
					</section>
			</section>
			<section>
				<section>
					<h1>Functor</h1>
				</section>
				<section>
					<h2>Functor in theory</h2>
					<ul>
						<li class="fragment">The term “functor” comes from category theory</li>
						<!-- <li class="fragment">Functor is a mapping between categories</li> -->
					</ul>
					<br>
					<br>
					<blockquote class="fragment">A functor is a container of type a that, when subjected to a function that maps from a→b, yields a container of type
						b.
					</blockquote>
					<br>
					<p><small>ref: <a href="http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor">what is functor</a></small></p>
					<aside class="notes">
						<p>Given a function that takes an a and returns a b and a functor with zero or more as inside it: fmap returns a box with
							zero or more bs inside it. The f a and f b bits can be read as “a functor of a” and “a functor of b”, meaning f a
							has as inside the box, and f b has bs inside the box.</p>
					</aside>
				</section>
				<section>
					<h2 class="">Fun Fun Functor</h2>
					<ul>
						<li class="fragment">An object with a .map() method</li>
						<li class="fragment">map method takes function as a parameter</li>
						<li class="fragment">maps from one set of values to another</li>
						<li class="fragment">Return another functor so that you can map further</li>
						<li class="fragment">Think functor as something <strong>mappable</strong></li>
						<li class="fragment">Like array, streams, trees, objects</li>
					</ul>
					<br>
					<blockquote class="fragment">
						A functor supplies a box with zero or more things inside, and a mapping interface.
					</blockquote>
					<aside class="notes">
						<h2>In Programming</h2>
					</aside>
				</section>
				<section>
					<h2>Functor has two laws</h2>
					<ol>
						<li>Identity</li>
						<li>Composition</li>
					</ol>
					<pre class="fragment"><code>
const functor = [1, 2, 3];
functor.map(x => x); // [1, 2, 3]
					</code></pre>
					<pre class="fragment"><code>
functor.map(x => f(g(x))) ≡ functor.map(g).map(f)
					</code></pre>
					<br>
					<p><small>Ref: <a href="https://medium.com/javascript-scene/functors-categories-61e031bac53f">Functors & Categories</a></small></p>
					<aside class="notes">
						<p>There are rules on how .map(f) should behave, so that it can qualifies as a functor.</p>
					</aside>
				</section>
				<section>
					<img src="images/functor.png" alt="">
				</section>
				<section>
					<h3>Functor</h3>
					<pre class="hljs javascript"><code>
const Container = x => ({
    map:(f) => Container(f(x)),
    toString(){return `Container(${x})`}
});
				</code></pre>
				<pre class="fragment hljs javascript"><code>
const inContainer = Container(5);
const mapped = inContainer.map(x => x*2)
mapped.toString(); //Container(10)
				</code></pre>
					<pre class="fragment"><code>
const transformValue = x => Container(x)
		.map(x => x*2)
		.map(x => x*3)
		.map(x => x+46)
		.map(x => String.fromCharCode(x))
					</code></pre>
				</section>
				<section>
					<h2>Promises are Functor</h2>
					<!-- <pre class="fragment"><code>
const tranfromImperateive = x => {
    const timesTwo = x*2;
    const timesThree = x*3;
    const plus46 = timesThree + 46;
    return String.fromCharCode(x);
}
					</code></pre> -->
					<pre class=" fragment hljs javascript"><code>
// promise is a functor
getUsers()
  .map(user => user.firstName)
  .map(firstName => firstName.toUpperCase());
					</code></pre>
					<br>
					<p><small>Ref: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">picture explanation of functor</a></small></p>
				</section>
				<!-- <section>
					<h2>Why Functors</h2>
					<p>Well, because functors help us solve a lot of problems when writing code in a functional style. We can use functors to manage null or undefined, to handle errors, to make async calls, among other things. They are an important piece of any functionally styled application.</p>
					<p><small>Ref: <a href="https://templecoding.com/blog/2016/06/16/functional-javascript-what-is-a-functor/"></a></small></p>
				</section> -->
			</section>
			<!-- <section>
				<section>
					<h1>maybe</h1>
				</section>
				<section>
					<h2>Maybe</h2>
					<pre><code data-trim>
						class Maybe {
						    constructor(val) {
						        this.__value = val;
						    }

						    map(f) {
						        return this.__value !== null && this.__value !== undefined ?
						        	Maybe.of(f(this.__value)) :
						        	Maybe.of(null);
						    }

						    static of(val) {
						        return new Maybe(val);
						    }
						}
					</code></pre>
				</section>
				<section>
					<h2>But I’ve heard that a Maybe is a Monad</h2>
<p>Well, Maybe could be a Monad as well. It only has to implement its interface and follow its rules. If you know a language like C# or Java, it’s the same as having a class that implements two different interfaces. So yeah, you can have a Maybe value that is a Functor and also a Monad.</p>
				<p>ref: <a href="http://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">maybe monads</a></p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Applicatives</h1>
				</section>
				<section>
					<p>Combine multiple functor into one functor</p>
					<img src="images/applicative1.png" alt="">
					<br>
					<p><small>Ref: <a href="https://buzzdecafe.github.io/code/2014/10/26/functors-and-applicatives">applicatives</a></small></p>
					<aside class="notes">
						<p>Applicatives take it to the next level. With an applicative, our values are wrapped in a context, just like Functors:</p>
						<p> which knows how to apply a function wrapped in a context to a value wrapped in a context:</p>
					</aside>
				</section>
				<section>
					<h2>Wrapped values</h2>
					<pre class="hljs javascript"><code data-trim>
var wrapped2 = [2];
var wrapped3 = [3];

//Won't work ! The values are wrapped.
add(wrapped2, wrapped3);
					</code></pre>
					<img class="fragment" src="images/applicative.png" alt="">
					<p><small><a href="https://medium.com/@tzehsiang/javascript-functor-applicative-monads-in-pictures-b567c6415221">applicatives in JS</a></small></p>
				</section>
				<section>
					<img src="images/applicatives.png" alt="">
					<br>
					<p><small>Ref: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">applicatives</a></small></p>
				</section>
			</section>
			<section>
				<section>
					<h1>Monads </h1>
				</section>
				<section>
					<h2>Monads in Two steps</h2>
					<ol>
						<li class="fragment">Get a PhD in Computer Science</li>
						<li class="fragment">Throw it away because you don't need PhD to understand Monad</li>
					</ol>
					<br><br>
					<blockquote class="fragment" cite="https://www.youtube.com/watch?v=dkZFtimgAcM">
						The moment you understand what is monads, is the moment you loose the ability to explain it to someone else.
					</blockquote>
				</section>
				<section>
					<h2>Functors, Applicatives</h2>
					<p class="fragment">Functors apply a function to a wrapped value</p>
					<img src="images/functor_tiny.png" alt="" class="fragment">
					<p class="fragment">Applicatives apply a wrapped function to a wrapped value</p>
					<img src="images/applicative_tiny.png" alt="" class="fragment">
				</section>
				<section>
					<h3>Monads</h2>
					<p class="fragment">Monads apply a function that <strong>returns a wrapped value to a wrapped value</strong></p>
					<pre class="fragment hljs javascript"><code>
const half = x => (x%2 === 0) ? [x/2] : [];
					</code></pre>
					<pre class="fragment"><code data-trim>
Array.prototype.flatMap = function(lambda) {
  return [].concat.apply([], this.map(lambda));
};
					</code></pre>
					<pre class="fragment"><code data-trim>
[3].flatMap(half); //[]
[4].flatMap(half); //[2]
[].flatMap(half); //[]
					</code></pre>
					<p class="fragment">Simple way: Monad is the container that Applies <strong>flatMap</strong></p>
					<aside class="notes">
						<h2>Why can't we use map</h2>
						<p>You might have the question that why don’t we just use map. I am glad you ask ! This is because half returns a wrapped value. If we use map, we are putting a container inside another container.</p>
					</aside>
					<p><small>Ref: <a href="https://medium.com/@tzehsiang/javascript-functor-applicative-monads-in-pictures-b567c6415221">monad in JS</a></small></p>
				</section>
				<section>
					<img style="height: 650px;" src="images/monad.png" alt="">
				</section>
				<section>
					<img style="height:650px;" src="images/monad2.png" alt="">
				</section>
				<section>
					<h2>Few Types of Monad</h2>
					<ul>
						<li><a href="http://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">Maybe moand</a></li>
						<li><a href="https://github.com/getify/Functional-Light-JS/blob/master/apB.md">Humble Monads</a></li>
						<li><a href="https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Monads in JS</a></li>
						<li><a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">Monads in Haskel</a></li>
						<li><a href="https://www.youtube.com/watch?v=dkZFtimgAcM">Monads</a></li>
						<li><a href="http://blog.klipse.tech/javascript/2016/08/31/monads-javascript.html">Explain monads by using this</a></li>
						
					</ul>
				</section>
				<!-- <section>
					<h2>Three Component</h2>
					<ol>
						<li class="fragment">
							<strong>Type constructor</strong>
							— a feature that creates a monadic type for the underlying type. For example it defines the type Maybe<number> for the underlying type number.
						</li>
						<li class="fragment">the unit function that wraps a value of underlying type into a monad. For the Maybe monad it wraps value 2 of the type number into the value Maybe(2) of the type Maybe<number></li>
						<li class="fragment">the bind function that chains the operations on a monadic values.</li>
					</ol>

type constructor — a feature that creates a monadic type for the underlying type. For example it defines the type Maybe<number> for the underlying type number.
the unit function that wraps a value of underlying type into a monad. For the Maybe monad it wraps value 2 of the type number into the value Maybe(2) of the type Maybe<number>.
the bind function that chains the operations on a monadic values.
					<p>ref: <a href="https://curiosity-driven.org/monads-in-javascript">Read more: Three types of monads</a></p>
					<aside class="notes">
						<p>To be considered a monad the structure has to provide three components:</p>

					</aside>
				</section>
				<section>
					<h2>IO Monads</h2>
					<p>IO monads is solution to a problem you will never have</p>
				</section>
				<section>
					<h2></h2>
					<pre class="hljs"><code>
function unit(value)
function bind (monad, function(value))
					</code></pre>
					<ul>
						<li>Monad is a object</li>
						<li>bind take a mond</li>
						<li>above function return monads</li>
					</ul>
				</section>
				<section>
					<h2>Three axiom of MOnads</h2>
					<ul>
						<li class="fragment"></li>
						<li class="fragment"></li>
						<li class="fragment">composition: bind(bind(monad, f
							<), g)/li>
					</ul>
				</section>
				<section>
					<h2>Identity MOnad</h2>
					<pre class="hljs"><code>
function MONAD(){
	return function unit (value){
		var monad = Object.create (null){
			return func(value);
		}
		retun monad;
	}
}
					</code></pre>
					<pre class="hljs"><code>
var identity = MONAD();
var monad = identity("hello world");
monad.bind(alert);
					</code></pre>
				</section>
				<section>
					<h2>MOnads</h2>
					<p>MOnads is functor with flatmap</p>
					<p>ref: <a href="https://www.youtube.com/watch?v=9QveBbn7t_c">Fun fun function</a></p>
				</section>
				<section>
					<h3> Side effects through monads</h3>
					<p>Another way of introducing side effects to a pure language is to simulate them using monads. While the language remains
						pure and referentially transparent, monads can provide implicit state by threading it inside them. The compiler does
						not even have to 'know' about the imperative features because the language itself remains pure, however usually the
						implementations do 'know' about them due to the efficiency reasons, for instance to provide O(1) mutable arrays. Allowing
						side effects only through monads and keeping the language pure makes it possible to have lazy evaluation that does
						not conflict with the effects of impure code. Even though lazy expressions can be evaluated in any order, the monad
						structure forces the effects to be executed in the correct order.</p>
				</section>
				<section>
					<h2>Debugging XXX</h2>
					<pre class="fragment"><code data-trim>
						var cube = (x) =>  x * x * x;
					</code></pre>
					<pre class="fragment"><code data-trim>
var cube = (x) => {
  console.log('cube was called.');
  return x * x * x;
};
					</code></pre>
					<p class="fragment1">But we’re not allowed to do this in a system that only allows pure functions: console.log() is neither an argument nor a return value of the function, it is a side effect.</p>
					<p>If we want to capture this logging information, it must form part of the return value. Let’s modify our functions to return a pair of values: the result, and some debugging information:</p>
				</section>
				<section>
					<h2>Return an arry</h2>
					<pre class="fragment"><code data-trim>
						var sine = (x) => [Math.sin(x), 'sine was called.'];
						sine(0.3218) // [ 0.31627467384831887,  "sine was called."]
					</code></pre>
					<pre class="fragment"><code data-trim>
						var cube = (x) =>  [x * x * x, 'cube was called.'];
						cube(3); //  [  27, "cube was called."]
					</code></pre>
					<h2>But we now find, to our horror, that these functions don’t compose:</h2>
					<pre><code data-trim>
						compose(sine, cube)(3);
						// [ NaN, "sine was called."]
					</code></pre>
				</section>
				<section>
					<h2>Broken two ways</h2>
					<ul>
						<li class="fragment">sine is trying to calculate the sine of an array, which results in null</li>
						<li class="fragment">we’re losing the debugging information from the call to cube</li>
					</ul>
					<p>We’d expect the composition of these functions to return the sine of the cube of x, and a string stating that both cube and sine were called:</p>
					<p>A simple composition won’t work here because the return type of cube (an array) is not the same as the argument type to sine (a number).</p>
					<p>A little more glue is required. We could write a function to compose these ‘debuggable’ functions: it would break up the return values of each function and stitch them back together in a meaningful way:</p>
					<pre class="fragment"><code data-trim>
						var composeDebuggable = (f, g) => (x) => {
						  const [y,s] = g(x),
						        [z,t ] = f(y);
						  return [z, s + t];
						};
						composeDebuggable(sine, cube)(3); // [
  0.956375928404503,
  "cube was called.sine was called.",
]
					</code></pre>
					<p>We’ve composed two functions that take a number and return a (number, string) pair, and created another function with the same signature, meaning it can be composed further with other debuggable functions.</p>
				</section>
				<section>
					<h2>Haskell to the rescue</h2>
					<p>To simplify things, let’s borrow some Haskell notation. The following type signature says that the function cube accepts a number and returns a tuple containing a number and a string:</p>
					<pre class="hljs haskell"><code>
cube :: Number -> (Number,String)
					</code></pre>
					<p>This is the signature that all our debuggable functions and their compositions have. Our original functions had the simpler signature Number -> Number.</p>
					<p>The symmetry of the argument and return types is what makes these functions composable. Rather than writing customized composition logic for our debuggable functions, what if we could simply convert them such that their signature was:</p>
					<pre><code>
cube :: (Number,String) -> (Number,String)
					</code></pre>
					<p>We could then use our original compose function for glueing them together. We could do this conversion by hand, and rewrite the source for cube and sine to accept (Number,String) instead of just Number but this doesn’t scale, and you end up writing the same boilerplate in all your functions.</p>
					<br>
					<p><small>Ref: <a href="http://blog.klipse.tech/javascript/2016/08/31/monads-javascript.html">Read the bottom part again</a></small></p>
				</section>
				<section>
					<h2>The Writer monad</h2>
					<p>Far better to let each function just do its job, and provide one tool to coerce the functions into the desired format. We’ll call this tool bind, and its job is to take a Number -> (Number,String) function and return a (Number,String) -> (Number,String) function.</p>
				</section>
				<section>
					<p>We’d expect the composition of these functions to return the sine of the cube of x, and a string stating that both cube and sine were called:</p>
					<pre><code>
						compose(sine, cube)(3)
						// -> [0.956, 'cube was called.sine was called.']
					</code></pre>
				</section>
				<section>
					<pre class="hljs javascript"><code data-trim>
						var composeDebuggable = function(f, g) {
						  return function(x) {
						    var gx = g(x),      // e.g. cube(3) -> [27, 'cube was called.']
						        y  = gx[0],     //                 27
						        s  = gx[1],     //                 'cube was called.'
						        fy = f(y),      //  sine(27) -> [0.956, 'sine was called.']
						        z  = fy[0],     //                 0.956
						        t  = fy[1];     //                 'sine was called.'

						    return [z, s + t];
						  };
						};

						composeDebuggable(sine, cube)(3)
						// -> [0.956, 'cube was called.sine was called.']
					</code></pre>
					<aside class="notes">
						<p>A simple composition won’t work here because the return type of cube (an array) is not the same as the argument type to sine (a number). A little more glue is required. We could write a function to compose these ‘debuggable’ functions: it would break up the return values of each function and stitch them back together in a meaningful way:</p>
					</aside>
				</section> -->
			</section>
			<section>
				<section>
					<h1>Summary 3</h1>
				</section>
				<section>
					<ul>
						<li>functor means mappable</li>
						<li class="fragment">wrapped value to wrapped value</li>
					</ul>
				</section>
			</section>
			<!-- <section>
				<section>
					<h2>Write declaratively, not imperatively</h2>
				</section>
			</section> -->
			<!-- <section>
				<section>
					<h1>Mix all you learned a heading!</h1>
				</section>
				<section>
					<h2>Familiar code</h2>
					<pre class="fragment"><code>
function validateSsn(ssn) {
	if (/^\d{3}-\d{2}-\d{4}$/.exec(ssn))
		console.log('Valid SSN');
	else
		console.log('Invalid SSN');
}
					</code></pre>
					<pre class="fragment hljs"><code>
function validatePhone(phone) {
    if (/^\(\d{3}\)\d{3}-\d{4}$/.exec(phone))
        console.log('Valid Phone Number');
    else
        console.log('Invalid Phone Number');
}
					</code></pre>
				</section>
				<section>
					<h2>Refactored Code</h2>
					<pre class="fragment hljs"><code>
function validateValue(value, regex, type) {
    if (regex.exec(value))
        console.log('Invalid ' + type);
    else
        console.log('Valid ' + type);
}
					</code></pre>
					<ul>
						<li class="fragment">one function is much better than two, three, four, etc</li>
						<li class="fragment">keeps your code clean and maintainable</li>
						<li class="fragment">if there’s a bug, you only have to fix it in one place</li>
					</ul>
					<aside class="notes">
						The parameters ssn and phone in the old code are now represented by value. The regular expressions /^\d{3}-\d{2}-\d{4}$/
						and /^\(\d{3}\)\d{3}-\d{4}$/ are represented by regex. And finally, the last part of the message ‘SSN’ and ‘Phone Number’
						are represented by type.
					</aside>
				</section>
				<section>
					<h2>What will you do here?</h2>
					<pre class="fragment hljs"><code>
function validateAddress(address) {
    if (parseAddress(address))
        console.log('Valid Address');
    else
        console.log('Invalid Address');
}
					</code></pre>
					<pre class="fragment hljs"><code>
function validateName(name) {
    if (parseFullName(name))
        console.log('Valid Name');
    else
        console.log('Invalid Name');
}
					</code></pre>
					<p>Here parseAddress and parseFullName are functions that take a string and return true if it parses.</p>
					<p>How do we refactor this?</p>
				</section>
				<section>
					<h2>Higher Order Function</h2>
					<ul>
						<li class="fragment">In Functional Programming, a function is a first-class citizen of the language.</li>
						<li class="fragment">In other words, a function is just another value.</li>
						<li class="fragment">Since functions are just values, we can pass them as parameters.</li>
						<li class="fragment">Higher-order Functions either take functions as parameters, return functions or both.</li>
					</ul>
					<p>ref: <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">read this</a></p>
				</section>
				<section>
					<h2>Search: IS JS a pure Functional program?</h2>
				</section>
				<section>
					<pre class="fragment hljs"><code>
function validateValueWithFunc(value, parseFunc, type) {
    if (parseFunc(value))
        console.log('Invalid ' + type);
    else
        console.log('Valid ' + type);
}
					</code></pre>
					<pre class="fragment hljs"><code>
validateValueWithFunc('123-45-6789', /^\d{3}-\d{2}-\d{4}$/.exec, 'SSN');
validateValueWithFunc('(123)456-7890', /^\(\d{3}\)\d{3}-\d{4}$/.exec, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						<p>Now we can call our higher-order function for the four previous functions (this works in Javascript because Regex.exec
							returns a truthy value when a match is found):</p>
					</aside>
				</section>
				<section>
					<h2> regular expressions bit verbose</h2>
					<pre class="fragment hljs"><code>
var parseSsn = /^\d{3}-\d{2}-\d{4}$/.exec;
var parsePhone = /^\(\d{3}\)\d{3}-\d{4}$/.exec;
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						<p>That’s better. Now when we want to parse a phone number, we don’t have to copy and paste the regular expression.</p>
						<p>But imagine we have more regular expressions to parse, not just parseSsn and parsePhone. Each time we create a regular
							expression parser, we have to remember to add the .exec to the end. And trust me, this is easy to forget.</p>
						<p>We can guard against this by creating a high-order function that returns the exec function:</p>
					</aside>
				</section>
				<section>
					<pre class="fargment hljs"><code>
function makeRegexParser(regex) {
    return regex.exec;
}
var parseSsn = makeRegexParser(/^\d{3}-\d{2}-\d{4}$/);
var parsePhone = makeRegexParser(/^\(\d{3}\)\d{3}-\d{4}$/);
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						Here, makeRegexParser takes a regular expression and returns the exec function, which takes a string. validateValueWithFunc
						will pass the string, value, to the parse function, i.e. exec. parseSsn and parsePhone are effectively the same as
						before, the regular expression’s exec function. Granted, this is a marginal improvement but is shown here to give an
						example of a high-order function that returns a function. However, you can imagine the benefits of making this change
						if makeRegexParser was much more complex.
					</aside>
				</section>
				<section>
					<h2>Convert OOP to FP</h2>
					<p><a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-54">convert in a nice way</a></p>
				</section>
			</section> -->
			<section>
				<section>
					<h1>Contrast with OOP</h1>
				</section>
				<section>
					<h2>Inheritance</h2>
					<ul>
						<li class="fragment">Inertance says what they are</li>
					</ul>
					<pre class="fragment"><code>
Dog
  .bark()					
					</code></pre>
					<pre class="fragment"><code>
Cat
  .meow()					
					</code></pre>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				<section>
					<h2>Inheritance</h2>
					<pre><code>
Dog
  .poop()
  .bark()					
					</code></pre>
					<pre><code>
Cat
  .poop()
  .meow()					
					</code></pre>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				<section>
					<h2>Inheritance</h2>
					<pre><code>
Animal
  .poop()					
					
  Dog
    .bark()					
	
  Cat
    .meow()					
					</code></pre>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				<section>
					<h2>Inheritance</h2>
					<pre><code>
CleaningRobot
  .drive()
  .clean()					
					</code></pre>
					<pre><code>
Animal
  .poop()					
  
  Dog
    .bark()					

  Cat
    .meow()					
					</code></pre>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				<section>
					<h2>Inheritance</h2>
					<pre><code>
MurderRobot
  .drive()
  .kill()
					</code></pre>
					<pre><code>
CleaningRobot
  .drive()
  .clean()					
					</code></pre>
					<pre><code>
Animal
  .poop()					
  
  Dog
    .bark()					

  Cat
    .meow()					
					</code></pre>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				
				<section>
					<pre><code>
Robot
  .drive()

  MurderRobot
    .kill()					
	
  CleaningRobot
    .clean()					
					</code></pre>
					<pre><code data-trim>
Animal
  .poop()					
					
  Dog
    .bark()					
	
  Cat
    .meow()					
					</code></pre>
					<h2 class="fragment">Murder Robot Dog?</h2>
					<p><small><a href="https://www.youtube.com/watch?v=wfMtDGfHWpA">composition vs inheritance</a></small></p>
				</section>
				<section>
					<h2>Kill, drive, bark & poop</h2>
					<pre><code data-trim>
Robot
  .drive()

  MurderRobot
    .kill()					
	
  CleaningRobot
    .clean()					
					</code></pre>
					<pre><code data-trim>
Animal
  .poop()					
					
  Dog
    .bark()					
	
  Cat
    .meow()					
					</code></pre>
					<p class="fragment">More higher level object???</p>
					<aside class="notes">
						<p>this will give you a lot of funcationality to your object that it might not use</p>
						<p>something like <strong>Gorilla - Banana Problem</strong></p>
						<ul>
							<li>You asked for a banana</li>
							<li>You get a gorilla holding a banana</li>
						</ul>
					</aside>
				</section>
				<section>
					<pre><code data-trim>
GameObject
  .bark()

   Robot
    .drive()

    MurderRobot
      .kill()					
		
    CleaningRobot
      .clean()					
		
      MurderRobotDog
		
	
					</code></pre>
		<pre><code>
  Animal
    .poop()					
							
    Dog
      .bark()					
			
    Cat
      .meow()		
		</code></pre>
					<aside class="notes">
						<p>Now cleaning robot gets <strong>bark</strong> which it doesnt need</p>
						<p>We get much more than we need</p>
					</aside>
				</section>
				<section>
					<pre><code data-trim>
Robot
  .drive()

  MurderRobot
    .kill()					
	
  CleaningRobot
	.clean()					
	
	MurderRobotDog
	  .bark()
					</code></pre>
					<ul>
						<li class="fragment">Getting more functionality than needed</li>
						<li class="fragment">Like <strong>Gorilla - Banana Problem</strong> </li>
						<li class="fragment">You asked for a banana</li>
						<li class="fragment">You get a gorilla holding a banana</li>
						
					</ul>
				</section>
				<section>
					<h2>Composition</h2>
					<ul>
						<li class="fragment">Inertance: Types are designed on what they are</li>
						<li class="fragment">Composition: Types are designed on what they do</li>
					</ul>
					<pre class="fragment"><code>
dog = pooper + barker
cat = pooper + meower

cleaningRobot = driver + cleaner
murderRobot = driver + killer

murderRobotDog = murderRobot + dog
					</code></pre>
					<pre class="fragment"><code>
poopingMurderRobot = murderRobot + pooper			
					</code></pre>
				</section>
				<section>
					<h2>Composition benefit</h2>
					<ul>
						<li class="fragment">On error, you will see a stack trace</li>
						<li class="fragment">Through every function down to the source of the bug</li>
						<li class="fragment">In OOP: it could be confusing</li>
						<li class="fragment">As you don’t always know the state of the rest of the object which led to the bug</li>
					</ul>
					<p><small><a href="https://medium.com/@chetcorcos/functional-programming-for-javascript-people-1915d8775504"></a></small></p>
				</section>
				<section>
					<h2>OOP and FP are not mutually exclusive</h2>
					<ul>
						<li class="fragment">Start with less side affect mind set</li>
						<li class="fragment">Prefer immutable data</li>
						<li class="fragment">Use pure function</li>
						<li class="fragment">Prefers declarative style</li>
						<!-- <li class="fragment">Write programming in a way to describing</li> -->
						<li class="fragment">Put Implementation detail packaged away</li>
						<li class="fragment">Target cleaner, readable code</li>
						<!-- <li class="fragment">Easier to reason about</li> -->
					</ul>
					<br>
					<br>
					<br>

					<aside class="notes">
						<p><strong>Side effects:</strong> minimize the number of changes to a programmer's state</p>
					</aside>
				</section>
				<!-- <section>
					<h2>Minimize side effect</h2>
					<ul>
						<li class="fragment">Side effect is a change that is not local to the function that caused it</li>
						<li class="fragment"></li>
					</ul>
					<pre class="fragment"><code class="hljs" data-trim>
					const x = 10;

					const myFunc = function (y){
						x = x + y;
					}

					myFunc(3);
					console.log(x); //13

					myFunc(3);
					console.log(x); //16
					</code></pre>
				</section>				 -->
			</section>
			<section>
				<section>
					<h1>Free tip</h1>
				</section>
				<section>
					<h2>My top 8 excuses</h2>
					<ol>
						<li class="fragment">It worked on my machine</li>
						<li class="fragment">Browser might be caching old content. hit <strong>Ctlr + F5</strong></li>
						<li class="fragment">You must have the wrong version</li>
						<li class="fragment">Ohh...I forgot to push the changes</li>
						<li class="fragment">That was only supposed to be a placeholder</li>
						<li class="fragment">It's not a true bug, it's a new feature</li>
						<li class="fragment">The guy who left, his code is causing this</li>
						<li class="fragment">It's a <strong>known issue</strong> in JavaScript</li>
					</ol>
					<aside class="notes">
						<p>Hit Cltr +F5</p>
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>Final Summary</h1>
				</section>
				<section>
					<h2>Functiona Programming</h2>
					<p class="fragment">Depending on whom you have asked: Functional programming</p>
					<ul>
						<li class="fragment">The <strong>mustachioed hipster</strong> of programming.</li>
						<li class="fragment">Or <strong>undigestible scientific theory</strong> for programming</li>
					</ul>
					<br>
					<br>
					<p class="fragment danger">It's coming to hunt you</p>
					<br>
					<p><small>Ref: <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">Functional Programming</a></small></p>
					<aside class="notes">
						<h2>Since it's on the hand on some hispter...it will grow</h2>
						<li >Depending on whom you ask, functional programming (FP) is either an enlightened approach to programming that should
							be spread far and wide, </li>
						<li>or an overly academic approach to programming with few real-world benefits.</li>
					</aside>
				</section>
			</section>
			<!-- <section>
				<h2>Conclusion</h2>
				<ul>
					<li class="fragment">The reason functional programming forces you to learn so much is because it challenges every assumption about writing
						software that you had. </li>
					<li class="fragment">ftentimes you can’t believe that some common thing can be done in a different way</li>
					<li class="fragment">if you are focused on get things done as the way you are comfortable dont change: <a href="https://ilikekillnerds.com/2016/09/functional-programming-javascript-like-dysfunctional/">read this</a></li>
					<li class="fragment"><a href="http://queue.acm.org/detail.cfm?id=2611829">Mostly functional programming does not work</a></li>
				</ul>
			</section> -->
			<!-- <section>
				<h2>Need more: still hungry</h2>
				<ul>
					<li><a href="https://www.youtube.com/watch?v=FGQAP0GxlW8">Why Functional Programming Matters - John Hughes, Mary Sheeran</a></li>
					<li>
						<a href="http://reactivex.io/learnrx/">Functional Programming in JavaScript</a>
					</li>
					<li><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">A practical introduction to Functional Programming</a></li>
					<li><a href="http://kachayev.github.io/talks/uapycon2012/">Functional programming in Python</a>
					<li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in Scala</a></li>
					<li><a href="http://www.vasinov.com/blog/16-months-of-functional-programming/">16 months of functional programming</a></li>
					<li>
						<a href="http://osteele.com/sources/javascript/functional/">Functional JavaScript</a>
					</li>
				</ul>
			</section> -->
			<section>
				<section>
					<h2>Who is</h2>
					<h1>JS   Dude?</h1>
				</section>
				<section>
					<img src="./images/dude.jpeg" alt="">
					<ul>
						<li style="color:purple"><strong>@jsdude005</strong></li>
						<li>Organizer Chicago JavaScript meetup</li>
						<li>Organize Chicago front end developers group</li>
						<li>This is my fifth year in that conference</li>
						<li>Giving talk all over the places</li>
						<li>Run Marathon, sky diving, tough mudder</li>
					</ul>
				</section>
				<!-- <section>
					<p><strong>Take advantages</strong></p>
					<ul>
						<li>Website: <strong style="color:purple">www.thatJSDude.com</strong></li>
						<li>Worskhop on React, Angular, JS, Interview process</li>
						<li>One to one training on career or any front end thing</li>
						<li>Interview preparation, Resume, interview preparation </li>
					</ul>
					<img style="height:350px;" src="./images/meetup.jpeg" alt="">
				</section>
				<section>
					<p><strong>React workshop</strong></p>
					<ul>
						<li>Build realistic website: <a href="https://ema-john.firebaseapp.com/">ema-john</a> </li>
						<li>100% money back gurantee</li>
						<li>20$ off if you sign up today</li>
						<li>August 19 on minneapolis.</li>
						<li>Just email: <strong style="color:purple">khan4019@gmail.com</strong></li>
					</ul>
					<img style="height:300px" src="./images/workshop1.JPG" alt="">
					<aside class="notes">
						<p>November 11 online</p>
					</aside>
				</section> -->
			</section>
			<section>
				<h2>khan4019@gmail.com</h2><br>
				<br>
				<!-- <p class="fragment"><a href="https://goo.gl/pdio1i">Slides twitted one hour ago <strong style="color:purple">@jsdude005</strong></a></p> -->
					
				<h4 class="hide1"><a href="https://khan4019.github.io/functional-programming">khan4019.github.io/functional-programming</a></h4>
				<br>
				
				<p>
					<a href="http://thatjsdude.com">ThatJSDude.com</a> / <a href="http://twitter.com/jsdude005">@jsdude005</a>
				</p>
				<p>
					<small><a href="http://www.youtube.com/c/ThatJSDude">khan4019@gmail.com</a></small>
				</p>
				<br>
				<br>
				<p><small>ohh, thanks for being here!</small></p>
			</section>
		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});
	</script>

</body>

</html>
