<!doctype html>
<html lang="en">

<head>
	<meta charset="utf-8">

	<title>Functional Programming: What Why and How</title>

	<meta name="description" content="An introductory talk for funcational programming in JavaScript">
	<meta name="author" content="That JS Dude">

	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<link rel="shortcut icon" href="images/favicon.jpg">
	<link rel="stylesheet" href="css/reveal.css">
	<link rel="stylesheet" href="css/theme/serif.css" id="theme">
	<link rel="stylesheet" type="text/css" href="css/extra-style.css">
	<!-- Theme used for syntax highlighting of code -->
	<link rel="stylesheet" href="lib/css/zenburn.css">

	<!-- Printing and PDF exports -->
	<script>
		var link = document.createElement('link');
		link.rel = 'stylesheet';
		link.type = 'text/css';
		link.href = window.location.search.match(/print-pdf/gi) ? 'css/print/pdf.css' : 'css/print/paper.css';
		document.getElementsByTagName('head')[0].appendChild(link);
	</script>

	<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
</head>

<body>

	<div class="reveal">

		<!-- Any section element inside of this container is displayed as a slide -->
		<div class="slides">
			<section>
				<section>
					<h2>Functional Programming</h2>
					<h3>What, Why and How</h3>
					<br>
					<br>
					<br>
					<br>
					<p>
						<a href="http://thatjsdude.com">ThatJSDude.com</a> / <a href="http://twitter.com/jsdude005">@jsdude005</a>
					</p>
					<p>
						<small><a href="http://www.youtube.com/c/ThatJSDude">youtube.com/c/ThatJSDude </a></small>
					</p>
				</section>
				<section>
					<img src="images/evolution.png">
				</section>
			</section>
			<section>
				<section>
					<h1>TODO</h1>
				</section>
				<section>
					<h2>Organize the talk</h2>
					<ol>
						<li>Intro</li>
						<li>level 1: pure, immutable, higher order: medium that and <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">here</a></li>
						<li>level 2: <a href="http://reactivex.io/learnrx/">something</a> </li>
						<li>level 3: monads, functor, etc. <a href="https://medium.freecodecamp.com/functional-programming-in-js-with-practical-examples-part-1-87c2b0dbc276">here: part 1 and 2</a></li>
					</ol>
				</section>
				<section>
					<h2>references</h2>
					<ul>
						<li>
							<a href="http://www.lihaoyi.com/post/WhatsFunctionalProgrammingAllAbout.html">Make a tea making diagram</a>
						</li>
						<li>
							<a href="http://www.braveclojure.com/functional-programming/">Closure: for the brave and true (read it)</a>
						</li>
						<li>
							<a href="http://stackoverflow.com/questions/36504/why-functional-languages">Why Functional Programming</a>
						</li>
						<li>
							<a href="http://www.defmacro.org/ramblings/fp.html">Read this as well</a>
						</li>
						<li>
							<a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/">Good slides: go through it all</a>
						</li>
						<li>
							<a href="https://medium.com/javascript-scene/why-learn-functional-programming-in-javascript-composing-software-ea13afc7a257">Read this and it's next parts</a>
						</li>
						<li>
							<a href="http://jrsinclair.com/articles/2016/gentle-introduction-to-functional-javascript-intro/">might get something from here</a>
						</li>
						<li>
							<a href="https://www.quora.com/Why-are-many-experienced-programmers-upset-at-functional-programming">Why experience developers upset on FP</a>
						</li>
						<li><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">Claims to be practical.. look at the examples</a></li>
						<li><a href="https://bethallchurch.github.io/JavaScript-and-Functional-Programming/">A good and simple collection</a></li>
						<li><a href="https://drboolean.gitbooks.io/mostly-adequate-guide/">Looks very good: Adequote function programming</a></li>
						<li>
							<a href=""></a>
						</li>
					</ul>
				</section>
				<section>
					<h2>JavaScript resources</h2>
					<ul>
						<li><a href="https://github.com/stoeffel/awesome-fp-js">collection of JS librarires</a></li>
						<li><a href="https://www.youtube.com/watch?v=dkZFtimgAcM">watch this: Douglus Crockford: Monads and Gonads</a></li>
						<li><a href="http://srirangan.net/2011-12-functional-programming-in-javascript">Some JS code examples</a></li>
						<li><a href="https://github.com/getify/Functional-Light-JS">Kyle simpson books about functional programming</a></li>
						<li><a href="https://www.barbarianmeetscoding.com/blog/2016/06/14/functional-programming-in-javascript/">Some example</a></li>
						<li><a href="http://dealwithjs.io/functional-programming-in-javascript/">Not very interesting</a></li>
						li><a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-48">ramada slide</a>
					</ul>
				</section>
			</section>
			<section>
				<h2>Bragging time!</h2>
				<p>I know you don't care</p>
				<p></p>
			</section>
			<section>
				<section>
					<h1>What</h1>
				</section>
				<section>
					<h2>Ask the geeky guy</h2>
					<ul>
						<li class="fragment">Monads, Functors</li>
						<li class="fragment">Immutable data</li>
						<li class="fragment">First class functions</li>
						<li class="fragment">Tail call optimization</li>
						<li class="fragment">Higher order functions</li>
						<li class="fragment">Lazy evaluation and determinism</li>
					</ul>
					<img class="fragment" src="images/speak.jpg">
					<aside class="notes">
						<p>after 40 minutes of talk during lunch break... my head starts spinning</p>
					</aside>
				</section>
				<section>
					<h2>Ask my manager</h2>
					<ul>
						<li>add pic: i asked a new hire: it a pain for new dev</li>
						<li>add pic: I asked my manager what is func? he said it's a pain for older developer</li>
					</ul>
				</section>
				<section>
					<h2>What the Func?</h2>
					<ul>
						<li class="fragment">Is this only a hype?</li>
						<li class="fragment">Is it a geeky thing?</li>
						<li class="fragment">Why it's called functional?</li>
						<li class="fragment">Is everything else is dysfunctional?</li>
						<li class="fragment">Why am I sitting here?</li>
						<li class="fragment">Btw, What would be served in the lunch?</li>
					</ul>
					<br>
					<p>ref: <a href="https://clojurefun.wordpress.com/2012/08/27/what-defines-a-functional-programming-language/">what is functional programming</a></p>
					<aside class="notes">
						<p>Finally, I got the brilliant idea to goole</p>
					</aside>
				</section>
				<section>
					<h4>Every major idea starts with Google search</h4>
					<img style="height: 600px;" src="images/day.jpg">
				</section>
				<section>
					<h2>Functional Programming</h2>
					<p class="fragment highlight-red">Find a definition</p>
				</section>
				<section>
					<h1>Can move rest of the things for later</h1>
				</section>
					<section>
						<h2>What, Why and How</h2>
					</section>
					<section>
						<h2>What</h2>
						<ul>
							<li class="fragment">Functional programming is the mustachioed hipster of programming paradigms.</li>
							<li class="hide">Originally relegated to the annals of computer science academia</li>
							<li class="fragment">Depending on whom you ask, functional programming (FP) is either an enlightened approach to programming that should
								be spread far and wide, </li>
							<li class="fragment">or an overly academic approach to programming with few real-world benefits.</li>
						</ul>
						<h2>Serious: take it after first section</h2>

						<p>ref: <a href="https://medium.com/javascript-scene/master-the-javascript-interview-what-is-functional-programming-7f218c68b3a0">Eric Elliot: Functional Programming</a></p>
					</section>
					<section>
						<h2>Why</h2>
					</section>
					<section>
						<h2>How (level-1)</h2>
						<ul class="fragment">Pure functions</ul>
						<ul class="fragment">Function composition</ul>
						<ul class="fragment">Avoid shared state</ul>
						<ul class="fragment">Avoid mutating state</ul>
						<ul class="fragment">Avoid side effects</ul>
					</section>
					<section>
						<h2>Extra: put somehwere</h2>
						<h4>Don't open that trap door!</h4>
						<p>Recall that the result of a function depends only on its inputs. Alas, almost all programming languages have "features"
							that break this assumption. Null values, type case (instanceof), type casting, exceptions, side-effects, and the possibility
							of infinite recursion are trap doors that break equational reasoning and impair a programmer's ability to reason about
							the behavior or correctness of a program. (Total languages, which do not have any trap doors, include Agda, Idris,
							and Coq.)</p>
						<p>Fortunately, as programmers, we can choose to avoid these traps, and if we are disciplined, we can pretend that the
							trap doors do not exist. This idea is called fast and loose reasoning. It costs nothing—almost any program can be
							written without using the trap doors—and by avoiding them you win back equational reasoning, composability and reuse.</p>
						<p>ref: <a href="https://opensource.com/article/17/4/introduction-functional-programming">Intro to Functional Programming</a></p>
						<p>Let's discuss exceptions in detail. This trap door breaks equational reasoning because the possibility of abnormal
							termination is not reflected in the type. (Count yourself lucky if the documentation even mentions the exceptions
							that could be thrown.) But there is no reason why we can't have a return type that encompasses all the failure modes.</p>
						<p>Avoiding trap doors is an area in which language features can make a big difference. For avoiding exceptions, algebraic
							data types can be used to model error conditions, like so:</p>
					</section>
			</section>
			<section>
				<section>
					<h1>What more</h1>
					<p>reduce what</p>
				</section>
				<section>
					<ul>
						<li class="fragment">building software by composing pure functions, avoiding shared state, mutable data, and side-effects. </li>
						<li class="fragment"> Functional programming is declarative rather than imperative, and application state flows through pure functions.
							Contrast with object oriented programming, where application state is usually shared and colocated with methods in
							objects.
						</li>
						<li class="fragment">Functional programming is a programming paradigm, meaning that it is a way of thinking about software construction
							based on some fundamental, defining principles (listed above). Other examples of programming paradigms include object
							oriented programming and procedural programming.</li>
						<li class="fragment">Functional code tends to be more concise, more predictable, and easier to test than imperative or object oriented
							code — but if you’re unfamiliar with it and the common patterns associated with it, functional code can also seem
							a lot more dense, and the related literature can be impenetrable to newcomers.</li>
						<li class="fragment">Functions are first-class entities: They can be assigned to variables, passed as arguments, or returned from other
							functions.
						</li>
					</ul>
				</section>
				<section>
					<ul>
						<li class="fragment">No state.</li>
						<li class="fragment">No side effects: Anything the code does except produce an output from given inputs.</li>
						<li class="fragment">programming with functions—pure mathematical functions.</li>
						<li class="fragment">result of a function depends only on the arguments, </li>
						<li class="fragment">there are no side effects</li>
						<li class="fragment">Programs are built by combining functions together</li>
					</ul>
				</section>
				<section>
					 the absence of side effects. It doesn’t rely on data outside the current function, and it doesn’t change data that exists outside the current function.
				</section>
			</section>
			<section>
				<section>
					<h1>Why</h1>
					<p>move this later</p>
				</section>
				<section>
					<ul>
						<li class="fragment">Code works more than it doesn’t.</li>
						<li class="fragment">Unit tests are easier to write.</li>
						<li class="fragment">Unit tests break faster allowing me to fix broken code they found faster.</li>
						<li class="fragment">Easier to figure out what the hell is going on in a larger code base. If something breaks, it’s easier to pull things
							apart and improve the testing of those parts to prevent it from happening again. Not like usual spaghetti that can
							occur with mutable state.</li>
						<li class="fragment">Don’t get bit (as much) by concurrency/parallelism bugs that can arise in server or testing environments.</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h1>Story</h1>
					<p>medium article: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-1-1f15e387e536">medium call</a></p>
				</section>
				<section>
					<p>more info in second part and third part</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Practical example of FP</h2>
					<br>
					<p><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">reference</a></p>
				</section>
				<section>
					<p>Many functional programming articles teach abstract functional techniques. That is, composition, pipelining, higher
						order functions. This one is different. It shows examples of imperative, unfunctional code that people write every
						day and translates these examples to a functional style.</p>
				</section>
				<section>
					<h2>A guide rope</h2>
					<p>When people talk about functional programming</p>
					<p>A dizzying number of “functional” characteristics</p>
					<ul>
						<p>These are language features that aid functional programming</p>
						<li class="fragment">mapping, reducing, pipelining, recursing, currying</li>
						<p>These are programming techniques used to write functional code</p>
						<li class="fragment">parallelization</li>
						<li class="fragment"> extra: <a href="http://stackoverflow.com/questions/1303794/how-is-debugging-achieved-in-a-lazy-functional-programming-language">How to debug lazy function</a></li>
						<p>These are advantageous properties of functional programs.</p>
					</ul>
				</section>
				<section>
					<h2>Ignore all that</h2>
					<ul>
						<li class="fragment">Functional code is characterized by one thing</li>
						<li class="fragment">The absence of side effects</li>
						<li class="fragment">It doesn’t rely on data outside the current function</li>
						<li class="fragment">it doesn’t change data that exists outside the current function</li>
						<li class="fragment">Every other “functional” thing can be derived from this property</li>
						<li class="fragment">Use it as a guide rope as you learn</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h2>Let's start</h2>
				</section>
				<section>
					<h2>This is a function</h2>
					<pre class="hljs"><code>
function add(x, y){
  return x + y;
}
					</code> </pre>
					<pre class="hljs fragment" data-trim><code>
add(1, 2); // output is 3
add(1, 2); // output still is 3
add(1, 2); // WILL ALWAYS output 3
					</code></pre>
					<p class="fragment">Only operate on their input parameters</p>
					<p class="fragment">
						Always produce the same output for same inputs.
					</p>
				</section>
				<section>
					<h2>What about this one?</h2>
					<pre class="hljs java" data-trim><code>
public int addNumbers(int x, int y) {
    int result = x + y;
    Database.write(result);
    return result;
}
					</code></pre>
					<pre class="fragment hljs"><code>
function mouseOnLeftSide(mouseX) {
    return mouseX < window.innerWidth / 2;
}
					</code></pre>
					<aside class="notes">
						<p>Not pure. </p>
						<p>Chnage the browser width and for same position of mouse the result varies</p>
						<p><strong>Impure is not testable</strong></p>
						<ul>
							<li class="">Bug: a user reported the function doesn't work for window is less than 500 px</li>
							<li class="">How do you test this?
								<ul class="">
									<li>manually test by loading up your browser</li>
									<li>write some unit tests</li>
								</ul>
							</li>
							<li class="">You can not write unit test</li>
							<li class="">function relies on window.innerWidth</li>
						</ul>
					</aside>
				</section>
				<section>
					<h2>Few more</h2>
					<pre class="hljs fragment"><code>
writeFile(fileName);
updateDatabaseTable(sqlCmd);
sendAjaxRequest(ajaxRequest);
openSocket(ipAddress);
					</code></pre>
					<ul>
						<li class="fragment">Rely on things outside of input parameter</li>
						<li class="fragment">Can't always predict their behavior/output</li>
						<li class="fragment">All these are <strong>impure function</strong></li>
						<li class="fragment">They will have <strong>side effect</strong></li>
						<li class="fragment">Pure functions have no side effects.</li>
					</ul>
					<aside class="notes">
						<p>In Imperative Programming Languages such as Javascript, Java, and C#, Side Effects are everywhere. This makes debugging
							very difficult because a variable can be changed anywhere in your program. So when you have a bug because a variable
							is changed to the wrong value at the wrong time, where do you look? Everywhere? That’s not good.</p>
					</aside>
				</section>
				<section>
					<h2>Impure function</h2>
					<p>In Imperative Programming Languages such as Javascript, Java, and C#, Side Effects are everywhere</p>
					<p class="fragment">This makes debugging very difficult because a variable can be changed anywhere in your program. </p>
					<p class="fragment">So when you have a bug because a variable is changed to the wrong value at the wrong time, where do you look? Everywhere?
						That’s not good.</p>
				</section>
				<section>
					<h2>Two type of functions</h2>
					<pre class="hljs" data-trim><code>
function add(x, y) {
    return x + y;
}
					</code></pre>
					<pre class="hljs fragment"><code>
function addAndSave(value){
	var result = x + y;
	Database.save(sum);
	  return result;
	}
}
					</code> </pre>
				</section>
				<section>
					<h2>Pure function</h2>
					<ul>
						<li>in a mathematical way...</li>
						<li class="fragment">Most useful Pure Functions must take at least one parameter.</li>
						<li class="fragment">All useful Pure Functions must return something.</li>
						<li class="fragment">always produce the same output given the same inputs.</li>
					</ul>
				</section>
				<section>
					<h2>Side effects</h2>
					<p>Define it here</p>
					<p>ref: <a href="http://poincare101.blogspot.com/2012/02/functional-programming-explained.html">FP: side effects</a></p>
				</section>
				<section>
					<h2>Functional Programming Language</h2>
					<ul>
						<li class="fragment">Cannot eliminate Side Effects completey</li>
						<li class="fragment">Can only confine them.</li>
						<li class="fragment"> Since programs have to interface to the real world, some parts of every program must be impure.</li>
						<li class="fragment"> The goal is to minimize the amount of impure code and segregate it from the rest of our program.</li>
					</ul>
				</section>
				<section>
					<h2>First class function</h2>
					<ul>
						<li>pass function</li>
						<li>return function</li>

					</ul>
					<p>add more</p>
				</section>
				<section>
					<h2>So far</h2>
					<p>Functional programming means: a lot functions</p>
				</section>
			</section>
			<section>
				<section>
					<h1>Immutibility</h1>
				</section>
				<section>
					<img src="images/immutable.png">
				</section>
				<section>
					<img src="images/mutable.png">
				</section>
				<section>
					<h2>Programming vs Math</h2>
					<pre class="hljs" data-trim><code>
var x = 1;
x = x + 1;
					</code></pre>
					<ul>
						<li class="fragment">In math, x can never be equal to x + 1</li>
						<li class="fragment">It's permitted in Imperative Programming</li>
						<li class="fragment">In functional programming, x = x + 1 is illegal</li>
						<li class="fragment">There are no variables in Functional Programming</li>
						<li class="fragment">Stored values are still called variables because of history but they are constants</li>
						<li class="fragment">Once x takes on a value, it’s that value for life</li>
					</ul>
					<aside class="notes">
						<p>Don’t worry, x is usually a local variable so its life is usually short. But while it’s alive, it can never change.</p>
					</aside>
				</section>
				<section>
					<blockquote cite="http://searchservervirtualization.techtarget.com/definition/Our-Favorite-Technology-Quotations">
						&ldquo;HOW THE HELL AM I SUPPOSED TO DO ANYTHING WITHOUT VARIABLES?!&rdquo;
					</blockquote>
				</section>
				<section>
					<h2>Example</h2>
					<pre class="hljs"><code>
function addOneTOSum(y,y){
	const x = 1;
	return x + y + z;
}
					</code></pre>
					<ul>
						<li class="fragment">x is bound to the value of 1</li>
						<li class="fragment">It’s equal to 1 for the rest of its life.</li>
						<li class="fragment">Its life is over when the function exits</li>
					</ul>
				</section>
				<section>
					<p>Let’s think about when we want to modify variables.</p>
					<ul>
						<li class="fragment">There are 2 general cases</li>
						<li class="fragment">1. multi-valued changes (e.g. changing a single value of an object or record)</li>
						<li class="fragment">2. single-valued changes (e.g. loop counters)</li>
						<li class="fragment  highlight-red">research this</li>
					</ul>
				</section>
				<section>
					<p class="fragment highlight-red">Isn't clear. read it again</p>
					<p>Functional Programming deals with changes to values in a record by making a copy of the record with the values changed.
						It does this efficiently without having to copy all parts of the record by using data structures that makes this possible.
						Functional programming solves the single-valued change in exactly the same way, by making a copy of it. Oh, yes and
						by not having loops.</p>
				</section>
				<section>
					<blockquote>
						“WHAT NO VARIABLES AND NOW NO LOOPS?! I HATE YOU!!!”
					</blockquote>
				</section>
				<section>
					<p>Hold on. It’s not like we can’t do loops (no pun intended), it’s just that there are no specific loop constructs like
						for, while, do, repeat, etc.</p>
					<p>Functional Programming uses recursion to do looping.</p>
				</section>
				<section>
					<h2>Immutability in JavaScript</h2>
					<pre class="hljs"><code>
const a = 1;
a = 2; // will throw error
					</code></pre>
					<pre class="hljs"><code>
const a = {
    x: 1,
    y: 2
};
a.x = 2; // NO EXCEPTION!
a = {};
					</code></pre>
					<p>ref: <a href="https://facebook.github.io/immutable-js/"> Immutable.js</a></p>
					<aside class="notes">
						<p>Here a is defined to be a constant and therefore cannot be changed once set. This is why a = 2 throws an exception</p>
						<p>The problem with const in Javascript is that it doesn’t go far enough. The following example illustrates its limits:</p>
						<p>Notice how a.x = 2 does NOT throw an exception. The only thing that’s immutable with the const keyword is the variable a. Anything that a points to can be mutated.</p>
						<p>Unfortunately, we can only do so via a library called Immutable.js. This may give us better immutability but sadly, it does so in a way that makes our code look more like Java than Javascript.</p>
					</aside>
				</section>
				<section>
					<h2>Looping in JavaScript</h2>
					<pre class="hljs"><code>
var sum = 0;
for (var i = 1; i <= 10; ++i){
	sum += i;
}
console.log(sum); // prints 55
					</code></pre>
					<pre class="fragment hljs"><code>
// without loop construct or variables (recursion)
function sumRange(start, end, sum) {
    if (start > end)
        return sum;
    return sumRange(start + 1, end, sum + start)
}
console.log(sumRange(1, 10, 0)); // prints 55
					</code></pre>
					<aside class="notes">
						<h2>Two ways to lopping in javascript</h2>
					</aside>
				</section>
				<section>
					<p>Notice how recursion, the functional approach, accomplishes the same as the for loop by calling itself with a new start
						(start + 1) and a new accumulator (acc + start). It doesn’t modify the old values. Instead it uses new values calculated
						from the old.</p>
					<p>You’re probably thinking that for loops are easier to understand. While that’s debatable and more likely an issue of
						familiarity, non-recursive loops require Mutability, which is bad.</p>
				</section>
				<section>
					<h2>benefits of Immutability</h2>
					<p>read <a href="https://medium.com/@cscalfani/why-programmers-need-limits-3d96e1a0a6db">this</a></p>
					<p>One obvious benefit is that if you have access to a value in your program, you only have read access, which means that
						no one else can change that value. Even you. So no accidental mutations.</p>
					<p>Also, if your program is multi-threaded, then no other thread can pull the rug out from under you. That value is constant
						and if another thread wants to change it, it’ll have create a new value from the old one.</p>
					<p>Immutability creates simpler and safer code.</p>
				</section>
			</section>
			<section>
				<section>
					<h2>Looping</h2>
				</section>
				<section>
					<h2>Iterate over lists</h2>
					<pre class="hljs javascript"><code>
let tasks = ['coding', 'drink coffee', 'hide from manager'];
let lengths = [];

for (let i = 0; i < tasks.length; i++){
  lengths.push(tasks[i].length);
}
console.log(lengths); //[6, 12, 17]
					</code> </pre>
					<pre class="hljs fragment"><code>
const tasks = ['coding', 'drink coffee', 'hide from manager'];

const lengths = tasks.map(function(task) {
  return task.length;
});

console.log(lengths); // [6, 12, 17]
					</code> </pre>
					<p>Middle of this page: <a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">use map</a></p>
					<aside class="notes">
						<ul>
							<li>declare far fewer variables</li>
							<li class="">Map takes a function</li>
							<li class="">And a collection of items</li>
							<li class="">It makes a new, empty collection</li>
							<li class="">runs the function on each item in the original collection</li>
							<li class="">inserts each return value into the new collection</li>
							<li class="">It returns the new collection</li>
						</ul>
					</aside>
				</section>
				<section>
					<h2>Reuse </h2>
					<pre class="hljs"><code>
function getLength(word) {
  return word.length;
}

var tasks = ['coding', 'drink coffee', 'hide from manager'];

var lengths = tasks.map(getLength);

console.log(lengths); // [6, 12, 17]
					</code> </pre>
				</section>
				<section>
					<h2>ES6</h2>
					<pre class="hljs"><code>
const getLength = word => word.length;

const tasks = ['coding', 'drink coffee', 'hide from manager'];

const lengths = tasks.map(getLength);

console.log(lengths); // [6, 12, 17]
					</code> </pre>
				</section>
				<section>
					<h2>ES6</h2>
					<pre class="hljs"><code>
const getLength = word => word.length;
const doubleIt = x => x*2;

const tasks = ['coding', 'drink coffee', 'hide from manager'];

const lengths = tasks.map(getLength).map(doubleIt);

console.log(lengths); // [12, 24, 34]
					</code> </pre>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">part 4: last part of the page</a></p>
				</section>
				<section>
					<h2>Fun Fun Functor</h2>
					<p>The term “functor” comes from category theory. In category theory, a functor is a mapping between categories. Loosely,
						a category is a group of things, where each “thing” can be any value. In code, a functor is sometimes represented as
						an object with a .map() method that maps from one set of values to another.</p>
					<p>When you see the word functor, you should think “mappable”.</p>
					<pre class="hljs haskel fragment"><code>
fmap :: (a -> b) -> f a -> f b
						</code></pre>
					<p>A functor supplies a box with zero or more things inside, and a mapping interface. An array is a good example of a functor,
						but many other kinds of objects can be mapped over as well, including single valued-objects, streams, trees, objects,
						etc…
					</p>
					<blockquote>A functor is a container of type a that, when subjected to a function that maps from a→b, yields a container of type
						b.
					</blockquote>
					<p>ref: <a href="http://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor">what is functor</a></p>
					<aside class="notes">
						<p>Given a function that takes an a and returns a b and a functor with zero or more as inside it: fmap returns a box with
							zero or more bs inside it. The f a and f b bits can be read as “a functor of a” and “a functor of b”, meaning f a
							has as inside the box, and f b has bs inside the box.</p>
					</aside>
				</section>
				<section>
					<h2>Functor Laws</h2>
					<ul>
						<li class="fragment">Categories have two important properties</li>
						<li class="fargment">Identity</li>
						<li class="fargment">Composition</li>
					</ul>
					<pre class="hljs fragment"><code>
const f = [1, 2, 3];
f.map(x => x); // [1, 2, 3]
						</code></pre>
					<pre class="hljs fragment"><code>

					</code></pre>
					<aside class="notes">
						<h4>Identity</h4>
						<p>If you pass the identity function (x => x) into f.map(), where f is any functor, the result should be equivalent to
							(have the same meaning as) f:</p>
					</aside>
				</section>
				<section>
					<h2>Add more from this </h2>
					<p>ref: <a href="https://medium.com/javascript-scene/functors-categories-61e031bac53f">Functors & Categories</a></p>
					<p>ref: <a href="https://templecoding.com/blog/2016/06/16/functional-javascript-what-is-a-functor/">another good to read</a></p>
				</section>
				<section>

					<ul>
						<li class="fragment">Functors are not function like map</li>
						<li class="fragment">Functor is an Object that has map method</li>
						<li class="fragment">For Example Array is a Functor as it has an implementation of map</li>
						<li class="fragment">Other example are promises, trees, strings, etc.</li>
					</ul>
					<br>
					<br>
					<p>ref: <a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">picture explanation of functor</a></p>
				</section>
			</section>
			<section>
				<section>
					<h2>Siblings of Map</h2>
				</section>
				<section>
					<h2>Filter</h2>
					<pre class="hljs"><code>
var numbers = [1, 2, 3, 4];
var newNumbers = [];

for(var i = 0; i < numbers.length; i++) {
    if(numbers[i] % 2 !== 0) {
        newNumbers[i] = numbers[i] * 2;
    }
}

console.log("The doubled numbers are", newNumbers); // [2, 6]
					</code></pre>
				</section>
				<section>
					<pre class="hljs"><code>
var numbers = [1, 2, 3, 4];

var newNumbers = numbers.filter(function(number){
    return (number % 2 !== 0);
}).map(function(number){
    return number * 2;
});

console.log("The doubled numbers are", newNumbers); // [2, 6]
					</code></pre>
					<p>ref: <a href="http://cryto.net/~joepie91/blog/2015/05/04/functional-programming-in-javascript-map-filter-reduce/">here</a></p>
				</section>
				<section>
					<h2>Reduce</h2>
					<ul>
						<li class="fragment">Reduce (aka: fold, accumulate)</li>
						<li class="fragment">takes a reducer function and an initial value</li>
						<li class="fragment">returns the accumulated value</li>
					</ul>
					<br>
					<p>ref: <a href="https://medium.com/javascript-scene/reduce-composing-software-fe22f0c39a1d">reduce</a></p>
					<aside class="notes">
						<p>commonly used in functional programming that lets you iterate over a list, applying a function to an accumulated value
							and the next item in the list, until the iteration is complete and the accumulated value gets returned. Many useful
							things can be implemented with reduce. </p>
					</aside>
				</section>
				<section>
					<h2>Reduce</h2>
					<pre class="hljs"><code>
//add reduce code
					</code></pre>
					<pre class="fragment"><code>
# in python
sum = reduce(lambda a, x: a + x, [0, 1, 2, 3, 4])

print sum
# 10
					</code></pre>
					<p>does reduce create new value each time</p>
					<aside class="notes">
						<p>Reduce takes a function and a collection of items. It returns a value that is created by combining the items.</p>
					</aside>
				</section>
				<section>
					<h2>Why map and reduce</h2>
					<ul>
						<li class="fragment">the important parts of the iteration - the collection, the operation and the return value - are always in the same
							places in every map and reduce.</li>
						<li class="fragment">the code in a loop may affect variables defined before it or code that runs after it. By convention, maps and reduces
							are functional.</li>
						<li class="fragment"> map and reduce are elemental operations. Every time a person reads a for loop, they have to work through the logic
							line by line. There are few structural regularities they can use to create a scaffolding on which to hang their understanding
							of the code. In contrast, map and reduce are at once building blocks that can be combined into complex algorithms,
							and elements that the code reader can instantly understand and abstract in their mind. “Ah, this code is transforming
							each item in this collection. It’s throwing some of the transformations away. It’s combining the remainder into a
							single output.”</li>
						<li class="fragment">map and reduce have many friends that provide useful, tweaked versions of their basic behaviour. For example: filter,
							all, any and find.</li>
						<li class="fragment">Search for more benefits</li>
					</ul>
				</section>
			</section>
			<section>
				<section>
					<h1>Composition</h1>
				</section>
				<section>
					<h2>Functiuon Composotion</h2>
					<pre class="hljs"><code>
const add10 = function(value) {
    return value + 10;
};
var mult5 = function(value) {
    return value * 5;
};
					</code></pre>
					<pre class="hljs"><code>
const add10 = x => x + 10;

const mult5 = x => x * 5;
					</code></pre>
					<pre class="hljs"><code>
var mult5AfterAdd10 = x => 5 * (x + 10);
					</code></pre>
					<aside class="notes">
						<p>let’s imagine that we also want to have a function that takes a value and adds 10 to it and then multiplies the result
							by 5. </p>
					</aside>
				</section>
				<section>
					<h2>There is a better way</h2>
					<p>In math, f ∘ g is functional composition and is read “f composed with g” or, more commonly, “f after g”. So (f ∘ g)(x)
						is equivalent to calling f after calling g with x or simply, f(g(x)).</p>
					<p> we have mult5 ∘ add10 or “mult5 after add10”, hence the name of our function, mult5AfterAdd10.</p>
					<p>And that’s exactly what we did. We called mult5 after we called add10 with value or simply, mult5(add10(value)).</p>
					<p>First, value is passed to add10 then its results are passed to mult5.</p>
					<br>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-3-1b0fd14eb1a7">part 3</a></p>
				</section>
				<section>
					<h2>Elm example</h2>
					<pre class="hljs elm"><code>
add10 value =
    value + 10
mult5 value =
    value * 5
mult5AfterAdd10 value =
    (mult5 << add10) value
					</code></pre>
					<pre class="hljs elm"><code>
f x =
   (g << h << s << r << t) x
					</code></pre>
					<aside class="notes">
						<p>Note the parentheses in mult5AfterAdd10, i.e. (mult5
							<< add10). They are there to make sure that the functions are
							 composed first before applying value.</p>
								<p>Here x is passed to function t whose result is passed to r whose result is passed to s and so on. If you did something
									similar in Javascript it would look like g(h(s(r(t(x))))), a parenthetical nightmare</p>
					</aside>
				</section>
				<section>
					<h2> Find other example of Compostion</h2>
				</section>
				<section>
					<h2>Point free notation</h2>
				</section>
				<section>
					<h2>More</h2>
					<pre class="hljs"><code>
add x y =
    x + y
mult5 value =
    value * 5
					</code></pre>
					<pre><code>
var mult5AfterAdd10 = mult5(add(10)); // this doesn't work
						</code></pre>
					<pre class="hljs fragment"><code>
var mult5AfterAdd10 = y => mult5(add(10, y)); // not point-free
						</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Currying</h1>
					<p>If you remember from Part 3, the reason that we were having problems composing mult5 and add (in ) is because mult5
						takes 1 parameter and add takes 2.</p>
					<p>We can solve this easily by just restricting all functions to take only 1 parameter.</p>
					<p>Trust me. It’s not as bad as it sounds.</p>
					<p>We simply write an add function that uses 2 parameters but only takes 1 parameter at a time. Curried functions allow us to do this.</p>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-4-18fbe3ea9e49">part4</a></p>
				</section>
				<section>
					<h2>Curried Function</h2>
					<blockquote>
						<p>A Curried Function is a function that only takes a single parameter at a time.</p>
					</blockquote>
					<p>This will let us give add its first parameter before we compose it with mult5. Then when mult5AfterAdd10 is called, add will get its second parameter.</p>
					<pre class="hljs"><code>
const add = x => y => x + y
					</code></pre>
					<pre><code>
function add(x){
	return function (y){
		return x + y;
	}
}
					</code></pre>
					<p>In detail, the add function takes a single parameter, x, and returns a function that takes a single parameter, y, which will ultimately return the result of adding x and y.</p>
					<aside class="notes">
						<p>This version of add is a function that takes one parameter now and then another one later.</p>
					</aside>
				</section>
				<section>
					<h2></h2>
					<p>Now we can use this version of add to build a working version of mult5AfterAdd10:</p>
					<pre><code>
var compose = (f, g) => x => f(g(x));
var mult5AfterAdd10 = compose(mult5, add(10));
					</code></pre>
					<p>The compose function takes 2 parameters, f and g. Then it returns a function that takes 1 parameter, x, which when called will apply f after g to x.</p>
					<p>So what did we do exactly? Well, we converted our plain old add function into a curried version. This made add more flexible since the first parameter, 10, can be passed to it up front and the final parameter will be passed when mult5AfterAdd10 is called.</p>
				</section>
				<section>
					<h2></h2>
					<p>At this point, you may be wondering how to rewrite the add function in Elm. Turns out, you don’t have to. In Elm and other Functional Languages, all functions are curried automatically.</p>
					<pre class="hljs elm"><code>
add x y =
    x + y
					</code></pre>
					<pre class="hljs elm"><code>
mult5AfterAdd10 =
    (mult5 << add 10)
					</code></pre>
					<aside class="notes">
						<p>Syntactically speaking, Elm beats Imperative Languages like Javascript because it’s been optimized for Functional things like currying and composition.</p>
					</aside>
				</section>
				<section>
					<h2>Currying and Refactoring</h2>
					<p>Another time currying shines is during refactoring when you create a generalized version of a function with lots of parameters and then use it to create specialized versions with fewer parameters.</p>
					<p>For example, when we have the following functions that put brackets and double brackets around strings:</p>
				</section>
				<section>
					<h2>Currying and Composition</h2>
<pre><code>
const f = a => b => c => d => a + b + c + d
console.log(f(1)(2)(3)(4)); // prints 10
</code></pre>
<pre class="fragment hljs"><code>
const f = R.curry((a, b, c, d) => a + b + c + d);
console.log(f(1, 2, 3, 4)); // prints 10
console.log(f(1, 2)(3, 4)); // also prints 10
console.log(f(1)(2)(3, 4)); // also prints 10
</code></pre>
				<p>Ref: <a href="http://ramdajs.com/"></a></p>
				<aside class="notes">
					<p>Too much parenthesis... might confuse you and make you cry.</p>
					<p>a framework named Ramada will rescue you</p>
					<p>The function definition isn’t much better but we’ve eliminated the need for all those parenthesis. Notice that we can apply as many or as few parameters as we want each time we invoke f.</p>
				</aside>
				</section>
				<section>
					<h2>RamadaJS</h2>
<pre class="hljs"><code>
//add old code here
</code></pre>
<pre class="fragment hljs"><code>
const add = R.curry((x, y) => x + y);
const mult5 = value => value * 5;
const mult5AfterAdd10 = R.compose(mult5, add(10));
</code></pre>
<pre class="fragment"><code>
const mult5AfterAdd10 = R.compose(R.multiply(5), R.add(10));
</code></pre>
				<aside class="notes">
					<p>Ramda has a lot of helper functions for doing these sorts of things, e.g. R.add and R.multiply, which means we can write less code:</p>
				</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>Monads </h1>
				</section>
				<section>
					<h2>Go Nerd with Monads</h2>
					<p>Raise your hands if you heard monads</p>
					<p>Can you explain monads!</p>
					<p>It is made popular by Haskel</p>
					<p>Warning: the moment you understand what is monads</p>
					<p>And you say... ohh...this is the monads</p>
					<p>This is the moment when you loose the ability to explain it to someone else</p>
					<p>ref: <a href="https://www.youtube.com/watch?v=dkZFtimgAcM">Monads</a></p>
				</section>
				<section>
					<h2></h2>
					<p>ref: <a href="http://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">May be you can starts with this</a></p>
					<p>ref: <a href="http://blog.klipse.tech/javascript/2016/08/31/monads-javascript.html">Explain monads by using this</a></p>
					<p>ref: <a href="https://curiosity-driven.org/monads-in-javascript">Three types of moands</a></p>
					<p>Can ignore things in below</p>
					<p>ref: <a href="https://www.youtube.com/watch?v=dkZFtimgAcM">Crokcford video</a></p>
					<p>ref: <a href="https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Monads in JS</a></p>
					<p>ref: <a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">monads in Haskel</a></p>
				</section>
				<section>
					<h2>IO Monads</h2>
					<p>IO monads is solution to a problem you will never have</p>
				</section>
				<section>
					<h2></h2>
					<pre class="hljs"><code>
function unit(value)
function bind (monad, function(value))
					</code></pre>
					<ul>
						<li>Monad is a object</li>
						<li>bind take a mond</li>
						<li>above function return monads</li>
					</ul>
				</section>
				<section>
					<h2>Three axiom of MOnads</h2>
					<ul>
						<li class="fragment"></li>
						<li class="fragment"></li>
						<li class="fragment">composition: bind(bind(monad, f
							<), g)/li>
					</ul>
				</section>
				<section>
					<h2>Identity MOnad</h2>
					<pre class="hljs"><code>
function MONAD(){
	return function unit (value){
		var monad = Object.create (null){
			return func(value);
		}
		retun monad;
	}
}
					</code></pre>
					<pre class="hljs"><code>
var identity = MONAD();
var monad = identity("hello world");
monad.bind(alert);
					</code></pre>
				</section>
				<section>
					<h2>MOnads</h2>
					<p>MOnads is functor with flatmap</p>
					<p>ref: <a href="https://www.youtube.com/watch?v=9QveBbn7t_c">Fun fun function</a></p>
				</section>
			</section>
			<section>
				<section>
					<h1>Need a heading!</h1>
				</section>
				<section>
					<h2>category theory</h2>
					<p>Search for category theory</p>
				</section>
				<section>
					<h2>Familiar code</h2>
					<pre class="fragment"><code>
function validateSsn(ssn) {
	if (/^\d{3}-\d{2}-\d{4}$/.exec(ssn))
		console.log('Valid SSN');
	else
		console.log('Invalid SSN');
}
					</code></pre>
					<pre class="fragment hljs"><code>
function validatePhone(phone) {
    if (/^\(\d{3}\)\d{3}-\d{4}$/.exec(phone))
        console.log('Valid Phone Number');
    else
        console.log('Invalid Phone Number');
}
					</code></pre>
				</section>
				<section>
					<h2>Refactored Code</h2>
					<pre class="fragment hljs"><code>
function validateValue(value, regex, type) {
    if (regex.exec(value))
        console.log('Invalid ' + type);
    else
        console.log('Valid ' + type);
}
					</code></pre>
					<ul>
						<li class="fragment">one function is much better than two, three, four, etc</li>
						<li class="fragment">keeps your code clean and maintainable</li>
						<li class="fragment">if there’s a bug, you only have to fix it in one place</li>
					</ul>
					<aside class="notes">
						The parameters ssn and phone in the old code are now represented by value. The regular expressions /^\d{3}-\d{2}-\d{4}$/
						and /^\(\d{3}\)\d{3}-\d{4}$/ are represented by regex. And finally, the last part of the message ‘SSN’ and ‘Phone Number’
						are represented by type.
					</aside>
				</section>
				<section>
					<h2>What will you do here?</h2>
					<pre class="fragment hljs"><code>
function validateAddress(address) {
    if (parseAddress(address))
        console.log('Valid Address');
    else
        console.log('Invalid Address');
}
					</code></pre>
					<pre class="fragment hljs"><code>
function validateName(name) {
    if (parseFullName(name))
        console.log('Valid Name');
    else
        console.log('Invalid Name');
}
					</code></pre>
					<p>Here parseAddress and parseFullName are functions that take a string and return true if it parses.</p>
					<p>How do we refactor this?</p>
				</section>
				<section>
					<h2>Higher Order Function</h2>
					<ul>
						<li class="fragment">In Functional Programming, a function is a first-class citizen of the language.</li>
						<li class="fragment">In other words, a function is just another value.</li>
						<li class="fragment">Since functions are just values, we can pass them as parameters.</li>
						<li class="fragment">Higher-order Functions either take functions as parameters, return functions or both.</li>
					</ul>
					<p>ref: <a href="https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99">read this</a></p>
				</section>
				<section>
					<h2>Search: IS JS a pure Functional program?</h2>
				</section>
				<section>
					<pre class="fragment hljs"><code>
function validateValueWithFunc(value, parseFunc, type) {
    if (parseFunc(value))
        console.log('Invalid ' + type);
    else
        console.log('Valid ' + type);
}
					</code></pre>
					<pre class="fragment hljs"><code>
validateValueWithFunc('123-45-6789', /^\d{3}-\d{2}-\d{4}$/.exec, 'SSN');
validateValueWithFunc('(123)456-7890', /^\(\d{3}\)\d{3}-\d{4}$/.exec, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						<p>Now we can call our higher-order function for the four previous functions (this works in Javascript because Regex.exec
							returns a truthy value when a match is found):</p>
					</aside>
				</section>
				<section>
					<h2> regular expressions bit verbose</h2>
					<pre class="fragment hljs"><code>
var parseSsn = /^\d{3}-\d{2}-\d{4}$/.exec;
var parsePhone = /^\(\d{3}\)\d{3}-\d{4}$/.exec;
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						<p>That’s better. Now when we want to parse a phone number, we don’t have to copy and paste the regular expression.</p>
						<p>But imagine we have more regular expressions to parse, not just parseSsn and parsePhone. Each time we create a regular
							expression parser, we have to remember to add the .exec to the end. And trust me, this is easy to forget.</p>
						<p>We can guard against this by creating a high-order function that returns the exec function:</p>
					</aside>
				</section>
				<section>
					<pre class="fargment hljs"><code>
function makeRegexParser(regex) {
    return regex.exec;
}
var parseSsn = makeRegexParser(/^\d{3}-\d{2}-\d{4}$/);
var parsePhone = makeRegexParser(/^\(\d{3}\)\d{3}-\d{4}$/);
validateValueWithFunc('123-45-6789', parseSsn, 'SSN');
validateValueWithFunc('(123)456-7890', parsePhone, 'Phone');
validateValueWithFunc('123 Main St.', parseAddress, 'Address');
validateValueWithFunc('Joe Mama', parseName, 'Name');
					</code></pre>
					<aside class="notes">
						Here, makeRegexParser takes a regular expression and returns the exec function, which takes a string. validateValueWithFunc
						will pass the string, value, to the parse function, i.e. exec. parseSsn and parsePhone are effectively the same as
						before, the regular expression’s exec function. Granted, this is a marginal improvement but is shown here to give an
						example of a high-order function that returns a function. However, you can imagine the benefits of making this change
						if makeRegexParser was much more complex.
					</aside>
				</section>
				<section>
					<h2>Another Higher order function</h2>
					<pre><code>
function makeAdder(constantValue) {
    return function adder(value) {
        return constantValue + value;
    };
}
					</code></pre>
					<pre class="fragment"><code>
var add10 = makeAdder(10);
console.log(add10(20)); // prints 30
console.log(add10(30)); // prints 40
console.log(add10(40)); // prints 50
					</code></pre>
					<aside class="notes">
						This behavior is very important because without it, functions that return functions wouldn’t be very useful. So it’s important
						we understand how they work and what this behavior is called. This behavior is called a Closure.
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h1>higher order function</h1>
				</section>
				<section>
					<ul>
						<li class="fragment">Function that take other function as parameter</li>
						<li class="fragment"></li>
					</ul>
				</section>
				<section>
					<h2>Functors</h2>
					<p>Higher-order functions can be usually simulated in object-oriented languages by functions that take function-objects,
						also called functors (note that functor in Haskell is an entirely different concept). Variables from the scope of the
						call can be bound inside the function-object which acts as if it were a closure. This way of simulating HOFs is, however,
						very verbose and requires declaring a new class each time we want to use a HOF.</p>
				</section>
				<section>

				</section>
			</section>
			<section>
				<section>
					<h1>Purity</h1>
				</section>
				<section>
					<ul>
						<li>Immutable data</li>
						<li>Referential transparency</li>
						<li>Lazy Evaluation</li>
						<li></li>
						<li></li>
					</ul>
				</section>
				<section>
					<h3> Side effects through monads</h3>
					<p>Another way of introducing side effects to a pure language is to simulate them using monads. While the language remains
						pure and referentially transparent, monads can provide implicit state by threading it inside them. The compiler does
						not even have to 'know' about the imperative features because the language itself remains pure, however usually the
						implementations do 'know' about them due to the efficiency reasons, for instance to provide O(1) mutable arrays. Allowing
						side effects only through monads and keeping the language pure makes it possible to have lazy evaluation that does
						not conflict with the effects of impure code. Even though lazy expressions can be evaluated in any order, the monad
						structure forces the effects to be executed in the correct order.</p>
				</section>
			</section>
			<section>
				<h2>Recursion</h2>
				<p>Recursion is heavily used in functional programming as it is the canonical and often the only way to iterate. Functional
					language implementations will often include tail call optimisation to ensure that heavy recursion does not consume excessive
					memory.
				</p>
				<p>check this slide: <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-30">here</a></p>
			</section>
			<section>
				<section>
					<h1>Referntial Transparency</h1>
				</section>
				<section>
					<h2>Referential Transparency </h2>
					<p>Referential Transparency is a fancy term to describe that a pure function can safely be replaced by its expression.</p>
					<pre class="hljs"><code>
y = x + 10
x = 3
y = 3 + 10
					</code></pre>
					<p>You could substituted x back into the equation</p>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">Not so good here: but you can use it</a></p>
				</section>
				<section>
					<pre class="hljs elm"><code>
quote str =
    "'" ++ str ++ "'"
					</code></pre>
					<pre class="hljs elm"><code>
findError key =
    "Unable to find " ++ (quote key)
					</code></pre>
					<pre class="hljs elm" data-trim><code>
findError key =
   "Unable to find " ++ ("'" ++ str ++ "'")
					</code></pre>
					<aside class="notes">
						<p>Since the quote function is pure, we can simply replace the function call in findError with the body of the quote function (which is just an expression)</p>
					</aside>
				</section>
			</section>
			<section>
				<section>
					<h2>Execution order</h2>
					<p>ref: <a href="https://medium.com/@cscalfani/so-you-want-to-be-a-functional-programmer-part-5-c70adc9cf56a">Not so good here: but you can use it</a></p>
				</section>
				<section>

				</section>
			</section>
			<section>
				<section>
					<h1>Type annotation</h1>
				</section>
				<section>
					<h2></h2>
					this is there
				</section>
			</section>
			<section>
				<h1>Immutability</h1>
			</section>
			<section>
				<h1>Currying and Composition</h1>
			</section>
			<section>
				<h1>Map, Filter and Reduce</h1>
			</section>
			<section>
				<section>
					<h1>Closure</h1>
				</section>
			</section>
			<section>
				<section>
					<h1>Composition</h1>
				</section>
				<section>
					<ul>
						<li class="fragment">Code reuse sounds great but is difficult to achieve.</li>
						<li class="fragment">Make the code too specific and you can’t reuse it.</li>
						<li class="fragment">Make it too general and it can be too difficult to use in the first place.</li>
						<li class="fragment">So what we need is a balance between the two, a way to make smaller</li>
						<li class="fragment"></li>
					</ul>
				</section>
				<section>
					<h2 class="fragment higlight-red"></h2>
					<pre><code>
var add10 = function(value) {
    return value + 10;
};
var mult5 = function(value) {
    return value * 5;
};
					</code></pre>
					<pre class="fragment"><code>
var add10 = value => value + 10;
var mult5 = value => value * 5;
					</code></pre>
				</section>
				<section>
					<pre class="fragment"><code>
var mult5AfterAdd10 = value => mult5(add10(value));
					</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Point free notation</h1>
				</section>
			</section>
			<section>
				<section>
					<h2>Write declaratively, not imperatively</h2>
				</section>
			</section>
			<section>
				<section>
					<h2>Use pipelines</h2>
				</section>
			</section>
			<section>
				<section>
					<h1>Section header</h1>
				</section>
				<section>
					<h2>Back to Basic</h2>
					<pre class="fragment"><code class="hljs" data-trim contenteditable>
							function double(x){
							   return 2*x;
							}
						</code></pre>
					<pre class="fragment"><code class="hljs" data-trim>
							var double = function(x){
								return 2*x;
							}
						</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h1>constrast with OOP</h1>
				</section>
				<section>
					<h2>Point of View</h2>
					<ul>
						<li class="fragment">Pomisese less side affect</li>
						<li class="fragment">Use immutable data</li>
						<li class="fragment">Use pure function</li>
						<li class="fragment">Prefers declerative style</li>
						<li class="fragment">Write programming in a way to describing</li>
						<li class="fragment">Implementation detail packaged away</li>
						<li class="fragment">Promises cleaner, readerable code</li>
						<li class="fragment">Easier to reason about</li>
						<li class="fragment"></li>
					</ul>
					<br>
					<br>
					<br>
					<p><a href="">refernces</a></p>
					<aside class="notes">
						<p><strong>Side effects:</strong> minimize the number of changes to a programmer's state</p>
					</aside>
				</section>

				<section>
					<h2>Touch Optimized</h2>
					<p>
						OOP and FP are not mutually exclusive
					</p>
				</section>
				<section>
					<h2>Minimize side effect</h2>
					<ul>
						<li class="fragment">Side effect is a change that is not local to the function that cuased it</li>
						<li class="fragment"></li>
					</ul>
					<pre class="fragment"><code class="hljs" data-trim>
					const x = 10;

					const myFunc = function (y){
						x = x + y;
					}

					myFunc(3);
					console.log(x); //13

					myFunc(3);
					console.log(x); //16
					</code></pre>
				</section>
				<section>
					<h2></h2>
					<p>When a function produces a side effect you have to know more than just its inputs and output</p>
					<p>to understand waht that function does</p>
					<ul>
						<li>you have to know the context and the history</li>
						<li class="fragment">It makes function harder and unpredictable</li>
						<li class="fragment">harder to test and could produce bug</li>
						<li class="fragment">Minimizing side effects is a fundamental principle of FP</li>
					</ul>
				</section>
			</section>


			<section>
				<section>
					<h2>Immutable</h2>
				</section>
				<section>
					<h2>Treat data as Immutable</h2>
					<ul>
						<li class="fragment">Immutable is not Mutatable</li>
						<li class="fragment">number, string, boolean are immutable</li>
						<li class="fragment">Objects, arrays are mutable</li>
						<li class="fragment"></li>
					</ul>
					<aside class="notes">
						<p>Ask who can tell the definition of immutable will get a prize. and then reveal the first line</p>
					</aside>
				</section>
				<section>
					<h2>Why you would like to avoid mutation</h2>
					<ul>
						<li class="fragment">Mutation has side effect</li>
						<li class="fragment">Less changes means less things to keep track</li>
						<li class="fragment"><code>Object.freeze</code></li>
						<li class="fragment">Object.freeze only freezes one level down</li>
						<li class="fragment">There are libraries to fix this issue <a href="">immutable</a></li>
					</ul>
				</section>
				<section>
					<h2>Avoid array mutation</h2>
				</section>
				<section>
					<h2>avoid object mutation</h2>
				</section>
				<section>
					<h2>const</h2>
					<ul>
						<li class="fragment">const is useful</li>
						<li class="fragment">does not make your data immutable</li>
						<li class="fragment">prevents variable being reassigned</li>
						<pre class="fragment"><code class="hljs" data-trim>
							const x = 1;
							x = 2; //not allowed

							const myArray = [1,2,3];
							myArray = [0, 2, 3]; // not allowed

							myArray[0] = 0; //allowed
						</code></pre>
					</ul>
				</section>
			</section>

			<section>
				<section>
					<h1>Pure Function</h1>
				</section>
				<section>
					<h2>Pure Function</h2>
					<ul>
						<li class="fragment">Does not change the program's state</li>
						<li class="fragment">Does not produce an observable side effect</li>
						<li class="fragment">Output relies solely on input values</li>
						<li class="fragment">Always return same output for same input</li>
						<li class="fragment">Indifferent to context</li>
						<li class="fragment">Highly testable and reusable</li>
					</ul>
					<aside class="notes">
						This slide has fragments which are also stepped through in the notes window.
					</aside>
				</section>
				<section>
					<h2>Make global variable local</h2>
					<pre><code class="hljs" data-trim>
						const myFunc = function(y){
							const x = 10;
							return x + y;
						}

						console.log(myFunc(3)); //13
						console.log(myFunc(3)); //13
					</code></pre>
				</section>
				<section>
					<h2>Pass as paramter</h2>
					<pre><code class="hljs" data-trim>
						const x = 10;
						const myFunc = function(x, y){
							return x + y;
						}

						console.log(myFunc(x, 3)); //13
						console.log(myFunc(x, 3)); //13
					</code></pre>
				</section>
				<section>
					<h2></h2>
					<ul>
						<li class="fragment">Ulitmate your program will always produce some side effects</li>
						<li class="fragment">You shoul handle them carefully</li>
						<li class="fragment">Constrained them as much as possible</li>
						<li class="fragment"></li>
					</ul>
				</section>
			</section>

			<section>
				<section>
					<h1>Composition</h1>
				</section>
				<section>
					<pre><code class="hljs" data-trim>
						const add = function(x,y){
							return x + y;
						}

						const square = function(x){
							return x * x;
						}

						const addThenSquare = function(x, y){
							return square(add(x,y));
						}
					</code></pre>
				</section>
				<section>
					<h2>g(f(x))</h2>
				</section>
				<section>
					<h2>more dynamic composition</h2>
				</section>
			</section>

			<section>
				<section>
					<h1>Partial function application</h1>
				</section>
				<section></section>
				<section></section>
			</section>

			<section>
				<section>
					<h2>Currying</h2>
					<p>Find a better example for curring in JS FP</p>
				</section>
				<section>
					<p>A Curried Function is a function that only takes a single parameter at a time.</p>
				</section>
				<section>

					<pre><code class="hljs" style="word-wrap: break-word;">&lt;section data-background="image.png" data-background-repeat="repeat" data-background-size="100px"&gt;</code></pre>
				</section>
			</section>
			<section>
				<section>
					<h1>Common Funcational Programming Functions</h1>
					<ul>
						<li>Map</li>
						<li>Filter</li>
						<li>Reduce</li>
						<li></li>
						<li></li>
					</ul>
					<p></p>
				</section>
				<section></section>
				<section></section>
				<section></section>
				<section></section>
			</section>
			<section>
				<section>
					<h1>Recursion</h1>
				</section>
			</section>

			<section>
				<section>
					<h1>Tail call Optimization</h1>
				</section>
				<section>
					<h2>Pretty Code</h2>
					<pre><code class="hljs" data-trim contenteditable>
						</code></pre>

				</section>
				<section>
					<p>also look at this slide: <a href="http://scott.sauyet.com/Javascript/Talk/FunctionalProgramming/#slide-34">here</a></p>
				</section>

			</section>

			<section>
				<h2>Method chaining</h2>
				<ul>

				</ul>
			</section>
			<section>
				<h2>Functional programming perf test</h2>
				<p>Done in ng conf</p>
			</section>
			<section>
				<section>
					<h1>Free tip</h1>
				</section>
				<section>
					<h2>How to date</h2>
				</section>
			</section>
			<section>
				<h2>Conclusion</h2>
				<ul>
					<li class="fragment">The reason functional programming forces you to learn so much is because it challenges every assumption about writing
						software that you had. </li>
					<li class="fragment">ftentimes you can’t believe that some common thing can be done in a different way</li>
					<li class="fragment">if you are focused on get things done as the way you are comfortable dont change: <a href="https://ilikekillnerds.com/2016/09/functional-programming-javascript-like-dysfunctional/">read this</a></li>
					<li class="fragment"><a href="http://queue.acm.org/detail.cfm?id=2611829">Mostly functional programming does not work</a></li>
					<li class="fragment"></li>
				</ul>
			</section>

			<section>
				<h2>Need more: still hungry</h2>
				<ul>
					<li>
						<a href="http://reactivex.io/learnrx/">Functional Programming in JavaScript</a>
					</li>
					<li><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming">a practical introduction to Functional Programming</a></li>
					li><a href="http://kachayev.github.io/talks/uapycon2012/">Functional programming in Python</a>
					<li><a href="https://www.manning.com/books/functional-programming-in-scala">Functional Programming in Scala</a></li>
					<li><a href="http://www.vasinov.com/blog/16-months-of-functional-programming/">16 months of functional programming</a></li>
					<li>
						<a href="http://osteele.com/sources/javascript/functional/">Functional JavaScript</a>
					</li>
					<li>
						<a href=""></a>
					</li>
					<li>
						<a href=""></a>
					</li>
					<li>
						<a href=""></a>
					</li>
				</ul>

			</section>

			<section>
				<h2>Thank you</h2>

			</section>


			<section style="text-align: left;">
				<h1>THE END</h1>

			</section>

		</div>

	</div>

	<script src="lib/js/head.min.js"></script>
	<script src="js/reveal.js"></script>

	<script>
		// More info https://github.com/hakimel/reveal.js#configuration
		Reveal.initialize({
			controls: true,
			progress: true,
			history: true,
			center: true,

			transition: 'slide', // none/fade/slide/convex/concave/zoom

			// More info https://github.com/hakimel/reveal.js#dependencies
			dependencies: [
				{ src: 'lib/js/classList.js', condition: function () { return !document.body.classList; } },
				{ src: 'plugin/markdown/marked.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/markdown/markdown.js', condition: function () { return !!document.querySelector('[data-markdown]'); } },
				{ src: 'plugin/highlight/highlight.js', async: true, callback: function () { hljs.initHighlightingOnLoad(); } },
				{ src: 'plugin/zoom-js/zoom.js', async: true },
				{ src: 'plugin/notes/notes.js', async: true }
			]
		});
	</script>

</body>

</html>
